<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>挖坑不填兽</title>
 <link href="http://marchliu.github.com/atom.xml" rel="self"/>
 <link href="http://marchliu.github.com"/>
 <updated>2013-04-08T12:47:03+08:00</updated>
 <id>http://marchliu.github.com</id>
 <author>
   <name>刘鑫</name>
   <email>march.liu@gmail.com</email>
 </author>

 
 <entry>
   <title>诚聘全职漫画助理【珠海】</title>
   <link href="http://marchliu.github.com/2013/04/08/job-vacancy"/>
   <updated>2013-04-08T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/2013/04/08/job-vacancy</id>
   <content type="html">
&lt;p&gt;矮人工匠工作室诚聘全职漫画助理（初级）⼀名， 协助工作室的漫画创作，参与电子书等
软件制作。工作地点在珠海，公司提供宽敞的办公空间，Mac电脑及Wacom绘图板，内部
培训机会，以及融洽的团队氛围。具体薪酬面议，约2500～3000/月，公司将依法为员工办
理全套应有社保福利。面试合格即可入职，试用期为三个月。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;【工作内容】&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;漫画场景绘制；&lt;/li&gt;
  &lt;li&gt;为部分漫画页面修图、上色；&lt;/li&gt;
  &lt;li&gt;输入文字页码等简单排版处理；&lt;/li&gt;
  &lt;li&gt;为本工作室的电子书及其他软件提供美工支援。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;【能力要求】&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;必备条件：&lt;/li&gt;
  &lt;ol&gt;
   &lt;li&gt;年龄20岁上下，男女不限；&lt;/li&gt;
   &lt;li&gt;中专/艺校或以上学历，美术或设计专业，有中等绘画基础；&lt;/li&gt;
   &lt;li&gt;熟练使用photoshop，会用painter，会制作简单矢量图；&lt;/li&gt;
   &lt;li&gt;耐心细致，能适应团队协作。&lt;/li&gt;
  &lt;/ol&gt;
  &lt;li&gt;加分项目：&lt;/li&gt;
  &lt;ol&gt;
    &lt;li&gt;擅长风景建筑绘画；&lt;/li&gt;
    &lt;li&gt;有软件美工经验；&lt;/li&gt;
    &lt;li&gt;有漫画创作经验；&lt;/li&gt;
    &lt;li&gt;对社会、历史、经济、旅行等题材有浓厚兴趣；&lt;/li&gt;
    &lt;li&gt;Mac用户。&lt;/li&gt;
     （注：工作电脑为Mac，因此要求至少能在试用期内学会使用Mac OS系统）
  &lt;/ol&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;【应聘材料】&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;个人简历⼀份（请准备PDF版本）；&lt;/li&gt;
  &lt;li&gt;原创手绘风景/街景素描（1～2张）；&lt;/li&gt;
  &lt;li&gt;原创漫画分镜，或广告故事板（1节内容，4页或以上）；&lt;/li&gt;
  &lt;li&gt;原创漫画故事作品（1～2件，任何形式，可以是四格、分镜故事或绘本故事）&lt;/li&gt;
  &lt;li&gt;原创CG彩页（1～2张）；&lt;/li&gt;
  &lt;li&gt;原创矢量图作品（2～4件，可大可小）。
    其中1、2、5、6必须有，3和4如果不是每项都有，那么请至少提供⼀项。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述项目之外，如有其他原创得意之作，不拘格式，敬请提供。&lt;/p&gt;

&lt;p&gt;【请注意】所有图片请用jpg或png格式，文件请用PDF格式，每个文件尺寸请勿超过
1M。&lt;/p&gt;

&lt;p&gt;请将所有应聘材料发送至：jeanyimcc AT gmail com&lt;/p&gt;

&lt;p&gt;我司将于近期在珠海为符合资格者安排面试，具体面试时间地点以邮件通知为准。
感谢垂注！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;矮人工匠工作室&lt;/p&gt;

&lt;p&gt;2013年4月7日&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>支持 WOW 5.2 的大脚 MAC 打包</title>
   <link href="http://marchliu.github.com/2013/03/15/bigfoot-for-wow-52"/>
   <updated>2013-03-15T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/2013/03/15/bigfoot-for-wow-52</id>
   <content type="html">
&lt;p&gt;没有任何技术含量，就是更新了5.2的支持…… &lt;a href=&quot;/static/BigFoot.zip&quot;&gt;下载链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wow_bf2.png&quot; alt=&quot;BigFoot&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>大脚文件下载链接错误</title>
   <link href="http://marchliu.github.com/2013/03/11/fix-bigfoot-download-link"/>
   <updated>2013-03-11T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/2013/03/11/fix-bigfoot-download-link</id>
   <content type="html">
&lt;p&gt;前几天，我发了一篇Blog &lt;a href=&quot;/2013/03/06/wow-bigfoot-mac-os-package&quot;&gt;WOW 大脚的 Mac 版打包&lt;/a&gt;，
放了一个WOW大脚的Mac包，因为原本就是给家人随便做的一个小东西，放上去以后也没注意看。偶然我发
现点击链接居然不能下载。（印象里也有读者反馈过，只是一下班我就忘了这个事情了）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/bigfoot403.png&quot; alt=&quot;Download 403&quot; /&gt;&lt;/p&gt;

&lt;p&gt;错误提示很奇怪，是权限问题，上图是我特意重现出来的。我回想一下，应该不是文件访问不到，因为我之前有同样在jekyll中放下载
链接并且下载成功的。这看起来像是……&lt;/p&gt;

&lt;p&gt;等等……如果仔细看URL，会发现有个很诡异的现象，就是最后有个/。这……其实是进入了一个目录吧……&lt;/p&gt;

&lt;p&gt;仔细回想了一下，Mac OS的应用程序有个非常不同于Windows/Linux的地方，它不是一个可执行文件，而是一个目录。是的，每个 
xxx.app 都是一个有特别结构的目录，如果你在任何一个app上右键，然后在弹出菜单上选“查看包内容”，会看到类似这样的结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/bigfoot_structure.png&quot; alt=&quot;Big Foot Structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Apple 的开发者文档，或者类似 Advanded Mac OS X Programming 这样的书里，有对 Mac OS 包的详细介绍，这里不
多解释了。这其实是个非常小的事情，但是有时候细节也会绊倒人。只能说庆幸这次不是错在工作项目吧：）。&lt;/p&gt;

&lt;p&gt;最后，&lt;a href=&quot;/2013/03/06/wow-bigfoot-mac-os-package&quot;&gt;原文&lt;/a&gt;的下载链接已经修正，也可以直接点击&lt;a href=&quot;/static/BigFoot.zip&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>帮朋友发个招聘启事（优逸科技）</title>
   <link href="http://marchliu.github.com/jobs/2013/03/07/job-opportunities-from-yoo-e"/>
   <updated>2013-03-07T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/jobs/2013/03/07/job-opportunities-from-yoo-e</id>
   <content type="html">
&lt;p&gt;优逸 &lt;a href=&quot;http://corp.yoo-e.com&quot;&gt;http://corp.yoo-e.com/&lt;/a&gt; ，大家有兴趣可以看看他们的网站，不多介绍了。简单的说是一个专注密码安全领域的企业。有硬件和软件的配套产品。他们现在要招一个软件开发方面的高级人才。&lt;/p&gt;

&lt;p&gt;这个公司我去年夏天去做过一个月（临时有个项目救急，过了最紧张的那段时间后我就回珠海创业了）。公司在天河公园旁边，员工福利待遇不错，有冰箱和微波炉，有请按摩师给员工按摩，有午休区，有员工宿舍（我住过，离公司很近，条件挺好）。公司的办公平台全面Google化，Google文档+企业邮箱。&lt;/p&gt;

&lt;p&gt;Leader是以前网易的技术总监范瑞恒，同行的朋友有些应该比我了解，我就不多介绍了，就我个人感觉，我觉得是非常好的领导，技术很强，人也挺实在。&lt;/p&gt;

&lt;p&gt;另外就是这家公司给的工资水平也不低，至少跟我谈的时候给的都很爽快。我相信这个长期的，正式的高级职位，肯定会是非常好的待遇。&lt;/p&gt;

&lt;p&gt;具体工作内容，就我上次工作的体验来看，还是比较综合性的岗位，做过高级程序员或开发经理的朋友应该都有体验，这种岗位很难说限于某一种技术领域的精通，往往项目来了，不管什么环境平台，都要吃的下。一个项目往往Linux、Windows、Python/C#/C 什么的，都有可能遇到，团队里几个人分担一下是会有，但是也要及可能都能搞得定，才能配合的了，特别是高级岗位。&lt;/p&gt;

&lt;p&gt;这个不是优逸的HR发的专业的文案，只是我随手写一下，很多东西都不精确，还请大家海涵。如果有兴趣，可以联系优逸的HR罗秋瑜女士：&lt;/p&gt;

&lt;p&gt;邮箱 qiuyu.luo@yoo-e.com
手机 13535400076&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>WOW 大脚的 Mac 版打包</title>
   <link href="http://marchliu.github.com/2013/03/06/wow-bigfoot-mac-os-package"/>
   <updated>2013-03-06T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/2013/03/06/wow-bigfoot-mac-os-package</id>
   <content type="html">
&lt;p&gt;中国的WOW玩家大多对大脚工具包不陌生。不过大脚只有windows版，MAC上装不了。其实 WOW 的插件都是LUA脚本，这个跟操作系统无关。我把最近版本的大脚脚本打了个包。可以点击这里&lt;a href=&quot;/static/BigFoot.zip&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/bigfoot.png&quot; alt=&quot;BigFoot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;安装与卸载&lt;/h2&gt;

&lt;p&gt;MAC用户只要运行这个app，点击“安装大脚”，选定WOW的安装路径，就可以安装大脚脚本。点击“卸载大脚”，选择WOW路径，就可以卸载大脚脚本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/bigfoot_install.png&quot; alt=&quot;Install BigFoot&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;声明&lt;/h1&gt;

&lt;p&gt;这个插件不是WOW大脚的官方作品，只是我作为一个魔兽老玩家，做来方便我太太使用大脚的同人作。它不能像真正的大脚官方客户端一样升级，仅仅是把 3.032 版的LUA脚本打了个包。将来如果大脚出MAC客户端，我肯定会抛弃这个app。而且我现在有自己的所以，有需要的MAC用户欢迎拿去用，但是我不保证其中的维护问题。如果将来有MAC的大脚客户端，请使用真正的大脚。&lt;/p&gt;

&lt;p&gt;最后，祝mac用户也能开开心心玩WOW！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wow_bf1.png&quot; alt=&quot;WOW BigFoot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wow_bf2.png&quot; alt=&quot;WOW BigFoot&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何给 Jekyll 的 Post 设定附图</title>
   <link href="http://marchliu.github.com/tech/2013/02/27/how-to-add-figure-in-jekyll-post"/>
   <updated>2013-02-27T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/tech/2013/02/27/how-to-add-figure-in-jekyll-post</id>
   <content type="html">
&lt;p&gt;我的公司 &lt;a href=&quot;http://dwarf-artisan.com&quot;&gt;Dwarf Artisan&lt;/a&gt; 的网站也是用Jekyll搭建的，但是它不是典型的博客网站，例如，首页需要展示一些固定的内容。我对 Jekyll 的深入也基本上都围绕内容展示进行。&lt;/p&gt;

&lt;p&gt;今天，我给文章加上了附图。这样，我可以在首页展示的时候，指定一张图片，而这个图片不一定也出现在正文。&lt;/p&gt;

&lt;p&gt;首页上的文章聚合基本上都是类似这样的逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
{% for post in site.posts %}
  {% if post.categories contains 'production' %}
  &amp;lt;hr&amp;gt;
  &amp;lt;h2&amp;gt;&amp;lt;a href=&quot;{{post.url}}&quot;&amp;gt;{{post.title}}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;  
  {{post.description}}
  &amp;lt;br&amp;gt;
  {% endif %}
{% endfor %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们扩展一下它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
{% for post in site.posts %}
  {% if post.categories contains 'production' %}
  &amp;lt;hr&amp;gt;
  &amp;lt;h2&amp;gt;&amp;lt;a href=&quot;{{post.url}}&quot;&amp;gt;{{post.title}}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;  
  {{post.description}}
  {% if post.figure %}
&amp;lt;a href=&quot;{{post.url}}&quot;&amp;gt;&amp;lt;img src=&quot;{{post.figure}}&quot;/&amp;gt;&amp;lt;/a&amp;gt;
  {% endif %}
  &amp;lt;br&amp;gt;
  {% endif %}
{% endfor %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中的 post.figure 是图片的url，那么这个url从何而来呢？&lt;/p&gt;

&lt;p&gt;我们建立一个 jekyll Page 或 Post 的时候，会看到文件最前面的声明头&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
---
layout: post
title: &quot;如何给 Jekyll 的 Post 设定附图&quot;
description: &quot;Jeklly 站点的页面可以附加元信息，用这种方法可以很方便的给Post设定附图。&quot;
category: tech
tags: [tech, web, jekyll]
---

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是本文的头，其实它是一段 YAML，我们只要给它加一个 figure 字段，指向一张图片，例如，我在本页添加了figure，读者可以看到效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: &quot;Dwarf Desktop Runner&quot;
description: &quot;Turn your desktop into a lively jokes runner!&quot;
categories: [productions, production]
tags: [Screen Dwarves, Desktop Runner]
figure: /images/new_da_home_page.png
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 jekyll 解释 index.md 时，就会把figure字段的内容取出，显示出来。下图是Dwarf Artisan 的新首页的一部分，我们可以看到，在本站首页上显示的 figure 其实是它的缩略图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/new_da_home_page.png&quot; alt=&quot;New Dwarf Artisan Home Page&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我用 Jekyll 重构了 Dwarf Artisan</title>
   <link href="http://marchliu.github.com/tech/2013/02/25/dwarf-artisan-rebuild-with-jekyll"/>
   <updated>2013-02-25T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/tech/2013/02/25/dwarf-artisan-rebuild-with-jekyll</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;意外的开始&lt;/h2&gt;

&lt;p&gt;好吧……我要承认，其实我是在 Dwarf Clipboard 提交审核（呃，这个产品因为技术问题被拒了，我还没决定它的去处，总不能一直在我们的代码仓库里睡觉）的时候才想起来其实 Mac OS App Store 需要一个 App 维护网站。于是，原本因为人力问题搁置的 &lt;a href=&quot;http://dwarf-artisan.com&quot;&gt;Dwarf Artisan&lt;/a&gt; 网站，就迫在眉睫了。我临时拿起 iweb，用差不多20分钟，拿内置模板架了一个网站。&lt;/p&gt;

&lt;p&gt;这个网站很好，iweb是个很赞的个人建站工具，它内置了很多漂亮的模板和组件，甚至允许我直接把iphoto的相册拖到页面上变成一个相册，而且这一切还都是纯静态的。这很省心。&lt;/p&gt;

&lt;p&gt;不过接下来就越来越麻烦，首先我不能让同事帮我编辑页面，因为 iweb 根本不能导出自己的文档，而且它只能把生成的网站同步出去，不能拉回来。&lt;/p&gt;

&lt;p&gt;第二件麻烦是是它不能直接编辑页面源码，至少我没找到。这个时候才让人明白fontpage有多良心。没有这个功能，不仅仅是不能写一些特效的问题，我不能在页面上放mailto、paypal、google analytics 之类的功能，想都别想，除非它们就出现在 iweb 的组件板上。&lt;/p&gt;

&lt;h2 id=&quot;jekyll--jekyll-bootstrap&quot;&gt;Jekyll 和 Jekyll bootstrap&lt;/h2&gt;

&lt;p&gt;首先是我们发现了 &lt;a href=&quot;http://pages.github.com&quot;&gt;github pages&lt;/a&gt; 服务，这很抢眼，每天我们用github服务工作的时候，很难忽略这东西的存在。接下来，从 pages，我们就知道了 &lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;jekyll&lt;/a&gt; ，简单玩了一下，这是个非常适合我们的技术。&lt;/p&gt;

&lt;p&gt;它很简单，用markdown书写内容，content和layout分开，而且可以自动生成静态页面——这足够了，反正我们的公司网站上没有什么动态逻辑。&lt;/p&gt;

&lt;p&gt;接下来，我的同事江南发现了它的 &lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;bootstrap 项目&lt;/a&gt; 。这个项目可以大大的减轻工作量，我们直接用它的设置就可以插入 google analytics，选用若干主题。&lt;/p&gt;

&lt;p&gt;很快，我搭建了一个原型，接下来遇到了一些麻烦，主要是 markdown 解释器的问题，有的中文支持不好（问题不算太大，但是总要以防万一），有的代码块功能实现的不好（这对一个技术团队也太重要了）。最终我选择了 kramdown 。然后我在我的个人 github pages （就是各位看到的这个站点）上做了一些实验，在选定theme以后，只剩了一个问题：相册。&lt;/p&gt;

&lt;h2 id=&quot;javascript-&quot;&gt;纯 Javascript 相册&lt;/h2&gt;

&lt;p&gt;除了产品展示，Dwarf Artisan 的网站上还有一些宝贵的东西：我们的朋友阎女士的&lt;a href=&quot;http://dwarf-artisan.com/columns/art/&quot;&gt;画作&lt;/a&gt;。无论如何，应该弄一个像样的相册工具放这些好东西吧。顺便说一下，Dwarf Artisan 只提供缩略图，对原作感兴趣可以直接联系作者，水印里有她的邮箱。&lt;/p&gt;

&lt;p&gt;这件事比预想的麻烦一些，我找了一些纯静态的Javascript相册代码，最后决定用了&lt;a href=&quot;http://www.twospy.com/galleriffic/index.html&quot;&gt;这个&lt;/a&gt;。不过sample的代码不能直接拿来用。有几个问题，首先js里有一些硬编码，依赖（很少）几个id，还有那么几个id跟我用的 jeykll 主题 Mark Reid 重名（所以它们的css混到了一起）。再就是 Mark Reid 主题的content区只有七百多像素宽，而这个相册的sample用掉了九百多个像素的宽度，直接嵌进去布局会混乱。经过一些细节调整，我做了一些妥协，初步达到了目的。&lt;/p&gt;

&lt;p&gt;目前我的做法是，如果我需要在我的某个 jekyll 网站上添加一个相册，就在那个网站的jekyll 根目录建立一个 images 目录，在里面建对应的相册路径，然后在这个根路径下执行脚本，传入相册子目录的名字作为相册名。脚本&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;会把图片剪裁成小尺寸以后放到对应的路径下，再生成一个模板片段，放到 _include/DA/ 目录下，然后就可以在需要它出现的地方include它了。&lt;/p&gt;

&lt;p&gt;当然，这不是正确的做法，这只是我赶工的结果，正确的做法应该是把它变成一个通用的模板，传入一个数组，然后include模板，就像 JB/setup 和 JB/post_collate 这种。我只是不太喜欢像&lt;a href=&quot;https://groups.google.com/forum/?fromgroups=#!topic/liquid-templates/qwE5hWk-Kik&quot;&gt;这位老兄一样&lt;/a&gt; 用split创建数组——不过，这是个好办法。&lt;/p&gt;

&lt;p&gt;我使用的代码放到了&lt;a href=&quot;https://github.com/Dwarfartisan/BlackCookbook/&quot;&gt;黑科技代码库&lt;/a&gt;。&lt;a href=&quot;https://github.com/Dwarfartisan/BlackCookbook/tree/master/ruby/jekyll-galleriffic&quot;&gt;在这里&lt;/a&gt;。欢迎随意取用，不过，这个代码没有经过任何改进，用之前最好自己处理一下，例如路径依赖什么的。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;好吧，我去掉了“自动”两个字，作为十年的Python用户得瑟自己会这种脚本也太逊了，哪怕这是我写的第三个还是第四个ruby脚本（不算去年写过的两千行puppet）……&lt;a href=&quot;#fnref:1&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>我的键盘体验</title>
   <link href="http://marchliu.github.com/other/2013/02/22/me-and-keyboard"/>
   <updated>2013-02-22T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/other/2013/02/22/me-and-keyboard</id>
   <content type="html">
&lt;p&gt;昨天朋友问起键盘的事情，我向他推荐了我自己在用的产品。为避免广告之嫌，就不详细列出品牌了，一个国产的 Cherry 轴机械键盘。&lt;/p&gt;

&lt;p&gt;今天朋友问为什么不用同样的预算选一个人体工学设计的键盘呢？&lt;/p&gt;

&lt;p&gt;嗯，我不是人体工学方面的专家，我挑选键盘，只是出于自身的使用体验，所以我的选择和观点未必适用其他人，更说不上科学，只是一个老电脑用户的喜好吧。&lt;/p&gt;

&lt;p&gt;我在这之前，也关注过很多年人体工学键盘，印象里我读大学的时候，宏碁出过一款三段式的人体工学键盘，波涛起伏的样子看起来非常拉风。不过那个价位对于学生也只能是看看而已。&lt;/p&gt;

&lt;p&gt;后来有机会接触到一些形状各异的人体工学键盘，基本上有这样几个思路：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;腕垫&lt;/li&gt;
  &lt;li&gt;凹形布局，减少手臂行程&lt;/li&gt;
  &lt;li&gt;鼓励用户把键盘放到膝上&lt;/li&gt;
  &lt;li&gt;改善按键手感&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个思路我觉得是对的，特别是第三点，可以是手腕更放松，是个减少疲劳的好方法。不过就我个人而言，键盘最大的区别仍然是按键。从去年开始，我买了两个键盘，一个茶轴一个黑轴。两种手感都非常好。虽然机械键盘比较笨重，布局也没有什么特别的地方，但是因为按键的感觉非常好，使得手指不容易疲劳。&lt;/p&gt;

&lt;p&gt;机械键盘指的是使用机械轴的键盘，常见的大多用的是德国 Cherry 的轴组装的。Cherry 的原厂键盘价位比较高，有说值得的也有说性价比低的，不过这是个比较主观的事情，不能就说 Cherry 的键盘真的不好。一个有意思的事情是因为工艺问题，传统上Cherry的键盘底盘是一块钢板，这使得Cherry键盘非常的重，而使用Cherry轴的兼容品牌有些是没有钢板的，要轻很多。很多用户将这种重量也视为品质的一部分，认为无钢板的兼容品牌手感不好。不过，好像最近Cherry也开始有无钢板的型号了……&lt;/p&gt;

&lt;p&gt;最后说说我自己的键盘使用体验吧。首先键盘的好坏，有大的趋势，但是具体的型号种类，其实是很个人化的东西，不能绝对。别人的前五位喜好里，很大可能也有最适合你的，但是别人最喜欢的，未必就是你最喜欢的，这个不用强求大家一样。&lt;/p&gt;

&lt;p&gt;键盘最重要的，仍然是按键，这也是机械键盘广受好评的根本原因，不过追求按键手感并非只有Cherry一种可选，更不是只有机械键盘可选。著名的高端键盘HHKB就是用的电容键，比Cherry族系的普遍价格高多了。十年前，我用过的键盘里手感最好的是罗技的易上手，当时也才买不到50元。&lt;/p&gt;

&lt;p&gt;就Cherry来说，现在还在量产的有四种轴，青轴和茶轴有段落感，红轴和黑轴没有。单就试用的感觉，青轴是我最喜欢的，但是据说快速击键的时候，青轴因为键程长，就会失去特有的段落声，所以我目前用的是茶轴，茶轴的力量更轻柔一点，确实也比较适合我的击键力量。其实长时间的体验后，我更喜欢无段落的黑轴，但是家里那个黑轴跟Mac OS不兼容（跟黑轴本身无关，是那个产品的双模驱动芯片跟Mac系统不兼容），所以只好放弃。红轴没用过，不好评价，据说比黑轴更轻柔，很适合击键轻快的用户。&lt;/p&gt;

&lt;p&gt;键盘的腕托对我确实是有改善疲劳的价值，但是没有特别大。特别是我视力不好，喜欢把显示器摆的比较近，桌面的空间就不够再放一个腕托，&lt;/p&gt;

&lt;p&gt;要想省空间，又想减轻手腕疲劳，其实把键盘放到低处是个更有效的方式，我现在最喜欢的姿势就是键盘放到膝盖上，双肘搭在座椅扶手上，这样省空间，也省力，比腕托方便有效。不过我不喜欢在桌面下放一个键盘托架，一来不如膝盖的姿势角度好，二来我喜欢座椅靠前（同样是因为眼神问题），所以把几位前东家的电脑桌下面的键盘托都弄坏过……&lt;/p&gt;

&lt;p&gt;最近流行站立工作，没有实验过，按说是个挺健康的选择——如果你不想站了可以随时坐下来……&lt;/p&gt;

&lt;p&gt;所以，我最终还是把钱花在了按键而不是键盘的形状上……&lt;/p&gt;

&lt;p&gt;对了，其实机械键盘还有一个广受欢迎的理由就是在游戏方面的表现，机械键盘结构坚固，手感稳定可靠，而且多个键同时按下也不会冲突（支持11个键无冲突的机械键盘不在少数），所以很多高端游戏玩家都喜欢用机械键盘。&lt;/p&gt;

&lt;p&gt;最后要说的是，无论再好的键盘、腕托和人体工学座椅，都不能代替定时起来走一走，休息休息的好习惯……&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>每天都被老婆打</title>
   <link href="http://marchliu.github.com/live/2013/02/17/wife-and-me-everyday"/>
   <updated>2013-02-17T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/live/2013/02/17/wife-and-me-everyday</id>
   <content type="html">
&lt;h3 id=&quot;section&quot;&gt;2013-02-26&lt;/h3&gt;

&lt;p&gt;“整天占我便宜，你都没什么便宜给我！哼！”“怎么没有，给你买的不都是便宜货……”“……”￥（**&amp;amp;¥ø∆&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2013-02-22&lt;/h3&gt;

&lt;p&gt;老婆打架输了，老婆不屑说，“弱爆了！”我回嘴，“还想怎样？你只有我一半重啊，不弱爆难道要强爆了？”气氛突然变的奇怪起来&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2013-02-20&lt;/h3&gt;

&lt;p&gt;昨天晚上老婆躺床上玩手机，我问“冷么？”“不冷啊。”听后我放心的拉过她的被子盖到自己身上……&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2012-11-28&lt;/h3&gt;

&lt;p&gt;你们觉得我黑？我家妹子曾经对我说：亲爱的，你厚了…… &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2012-10-15&lt;/h3&gt;

&lt;p&gt;今天妹子来公司，我搬出到货几天秋毫无犯的一体机，请她帮忙安装，结婚快六年，儿子马上五岁，她终于意识到，其实我不会修电脑…… #每天都被老婆打#&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2012-10-12&lt;/h3&gt;

&lt;p&gt;“去鼠熟公司坐坐不？”“……”“鼠熟给你煮咖啡。”“￥&amp;amp;@&lt;em&gt;”“不熟也不要打这么重啊！”“（&lt;/em&gt;&amp;amp;*…”……好吧……貌似在中午的超市电梯上跟老婆玩这种游戏，周围的人是略多了点……#每天都被老婆打#&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2012-10-11&lt;/h3&gt;

&lt;p&gt;有次我家妹子问我，如果家里买车，谁开比较好？我琢磨了一下，答：一个是天然呆加路痴，一个是暴走机甲萝莉，咱们还是等儿子长大再买车吧…… #每天都被老婆打#&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2012-10-5&lt;/h3&gt;

&lt;p&gt;我自问口齿还算伶俐，特别是在熟人面前还是比较放的开的，但是跟老婆斗嘴，只要她说“你妹啊！”，我就只好认输，这个实在没办法回嘴，因为她真的有个妹妹…… #每天都被老婆打#&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2012-8-19&lt;/h3&gt;

&lt;p&gt;有几天，就不久之前吧，有回说着说着话，我托起 @millyliu 的下巴，往她嘴里看。@millyliu 说你干嘛啊。我：据说，后槽牙很性感…&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2012-4-18&lt;/h3&gt;

&lt;p&gt;这是旧事了，第一回帮老婆买卫生巾，心说这事儿我不专业啊，让超市的服务员帮我挑一包吧。拿回家就被鄙视了。这真不怪我啊……我怎么知道这世界上还有薄荷味儿的卫生巾啊……这是哪个奇葩造出来的啊！&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2012-4-13&lt;/h3&gt;

&lt;p&gt;送儿子到幼儿园，回来吃早饭。说起儿子各种不省心，我忿然批判：都是你肚皮不争气，生个赔钱货！老婆不满的回答：这能怪我吗？难道肚皮上面的事也是我负责吗？我忍了半天没忍住，趴在老婆腿上狂笑……&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2012-4-12&lt;/h3&gt;

&lt;p&gt;路上看到mini cobo，老婆开玩笑说让我买，我沉思了一下说，mini……对三口之家……有点小吧……要不我们买个大的？老婆：大奔？我：大发……&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;2012-3-11&lt;/h3&gt;

&lt;p&gt;出差前有一天，我跟老婆说话呢，突然看到她头上……“老婆，你有根白头发……”，老婆小嘴巴:(，低下头静静的让我伸手到头发里慢慢捻……慢慢取下来一根白色的……鸭绒……好吧再好的羽绒服也会有点漏毛啊……&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;2012-3-6&lt;/h3&gt;

&lt;p&gt;有回跟老婆打电话，俩人正闹呢，我要亲她，一撅嘴，把电话挂了……触屏智能机真垃圾……&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;2012-3-1&lt;/h3&gt;

&lt;p&gt;@millyliu：刚刚年糕问我：妈妈，为什么你不买剑呐？我说我买啦，但是你都玩坏了。。年糕就很急着说：我没有玩坏，是你弄坏嗒！！是你在打爸爸的时候打坏嗒！！我就囧了。。。我都忘了，你还记得啊！！@刘鑫-MarchLiu&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;2012-2-22&lt;/h3&gt;

&lt;p&gt;我有段时间喜欢把孩子抛起来，总被老婆骂，后来朋友就画了&lt;a href=&quot;http://www.douban.com/note/165226229/&quot;&gt;这个&lt;/a&gt; … &lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;2012-2-15&lt;/h3&gt;

&lt;p&gt;老婆让我看她屏幕上的耳环照片，我做瞎子状摸眼镜。老婆见状，拉过我的手就咬了一口，惨叫声后，老婆做可爱状：这是儿子咬的，你看不到，我看到了。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;2012-2-15&lt;/h3&gt;

&lt;p&gt;@millyliu：就在刚刚，我对胖子说：看我病的，我要是死了，就都是你害的！胖子娇羞的趴在我旁边轻声说：你要回来保佑我们喔~&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;2012-2-14&lt;/h3&gt;

&lt;p&gt;儿子在自行车店看上一辆奥特曼自行车，缠着妈妈要买，妈妈说家里已经有一辆大鲨鱼了，不可以再买。儿子很沮丧，一直嘟囔要乌贼奥特曼自行车，我安慰他：“等你长大，16岁生日的时候，老爸买一辆最漂亮的漆着乌贼奥特曼的自行车送到你的中学，让你的全班同学都看到。”儿子开心了。&lt;/p&gt;

&lt;h3 id=&quot;section-19&quot;&gt;2012-2-13&lt;/h3&gt;

&lt;p&gt;趁老婆挑螃蟹，抱着儿子假装要咬他，结果玩太 high 把脸扭了&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;2012-2-12&lt;/h3&gt;

&lt;p&gt;今天跟小七妲拉两口子吃饭，他们观察以后的结论是，建议我把这个tag改为 #每天都被老婆打很多次#&lt;/p&gt;

&lt;h3 id=&quot;section-21&quot;&gt;2012-2-11&lt;/h3&gt;

&lt;p&gt;十一点多的时候老婆说让我去买个麦当劳，我换好衣服，穿上鞋，带好手机、钥匙、钱包，走到门口，回过头，双手扶住老婆的肩膀，跟她说：我走了，照顾好我们的孩子。老婆：#%￥@）*……&lt;/p&gt;

&lt;h3 id=&quot;section-22&quot;&gt;2012-2-10&lt;/h3&gt;

&lt;p&gt;作为下厨房的员工，我是不会告诉你们我还做过培根茶树菇卷这么欠揍的菜……&lt;/p&gt;

&lt;h3 id=&quot;section-23&quot;&gt;2012-2-7&lt;/h3&gt;

&lt;p&gt;刚才老婆兴冲冲告诉我，有次她妹妹抱不动我儿子，儿子跟小姨说：你吃饭太少了，要像我爸爸吃那么多才有力气。……#￥（@！……#！&amp;amp;&lt;/p&gt;

&lt;h3 id=&quot;section-24&quot;&gt;2012-2-6&lt;/h3&gt;

&lt;p&gt;说起来有一回真冤，我就因为转了 @恰好 的一句微博就被老婆打了……恰好说，回家过年时亲戚问为什么不结婚，就回答：因为女方还没有成年……&lt;/p&gt;

&lt;p&gt;我太太虽然人看着小小的，但是在家说话还是很有分量的，曾经我家有瓶腐乳不听话，怎么都拧不开，我太太就拿来拧了一下……下图场面血腥，慎入。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/furu.jpg&quot; alt=&quot;腐乳&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-25&quot;&gt;2012-2-5&lt;/h3&gt;

&lt;p&gt;前天晚上带了本书进卧室，把书往枕头下一放，灯一关，傻眼了：啥都看不见。被老婆狂嘲笑。昨天晚上就想着不能再带书了，拿了纸笔进去，灯一关……&lt;/p&gt;

&lt;h3 id=&quot;section-26&quot;&gt;2012-2-4&lt;/h3&gt;

&lt;p&gt;老婆，我的眼镜呢？-这里啦！什么都问我，我到底是你什么啊？-（想了想）你是我的明星，（凑上前）你是我前进的方向，（伸出手）你是我触手可及的所在……（老婆奋起暴打）……&lt;/p&gt;

&lt;h3 id=&quot;section-27&quot;&gt;2012-2-3&lt;/h3&gt;

&lt;p&gt;刚才老婆看到这条，于是我又被打了……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;@刘鑫-MarsLiu：#每天都被老婆打# 今天又被老婆打了，但是写出来只能是[马赛克][马赛克][马赛克][马赛克][马赛克][马赛克][马赛克]……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;老婆在吃巧克力，她嫌我吃太快，好半天才给我一块，你们别告诉 @millyliu 为什么这会儿我特别爱跟她接吻……&lt;/p&gt;

&lt;h3 id=&quot;section-28&quot;&gt;2012-2-2&lt;/h3&gt;

&lt;p&gt;走在路上，老婆指给我看：你看，那边的房子很大哦，还都是复式，咱们家以后就看你了哦～“看我就行？”“对啊。”“那我回家照照镜子，也多看我几眼……”&lt;/p&gt;

&lt;p&gt;卫生间灯坏了，换了一个没亮。“看来是镇流器坏了，找师傅换个新的吧。”“别人家都有自己换的，你就不能换？”“师傅比较专业嘛。”“那要你干什么？”“生孩子嘛……”虽然很小声还是被狂揍了……&lt;/p&gt;

&lt;p&gt;这个事情很多年了，过去提过，但是每次想起来……还是会被打……话说太太怀孕六个月的时候，我们俩在便利店，看着一冰柜奶茶，我突然很温情（从八岁开始有练习朗诵哦）的对她说，如果我有一瓶奶茶，一半给你，一半给孩子……她静默了几秒，我继续：然后我去再买一瓶……&lt;/p&gt;

&lt;p&gt;老婆前两天买了袋湿花生，昨晚写程序的时候拿出来吃，吃着吃着我跟老婆说：花生好像发酸了……老婆说：那你还吃？我：多吃几颗才能确认……&lt;/p&gt;

&lt;p&gt;老婆在赶工，突然感慨的说，这个显示器太小了！好不习惯啊！我好怀念那个23寸的显示器啊！我看了看她的17寸显示器，看了看我面前MBP 13寸屏幕里拥挤的xcode，默默的流下了泪水……&lt;/p&gt;

&lt;h3 id=&quot;section-29&quot;&gt;2012-2-1&lt;/h3&gt;

&lt;p&gt;在超市，老婆要买黑人牙膏，我上下左右寻了半天，拿起一盒黑妹牙膏：“女黑人牙膏行么？”&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Python TDD IN EMACS</title>
   <link href="http://marchliu.github.com/tech/2013/02/17/python-tdd-in-emacs"/>
   <updated>2013-02-17T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/tech/2013/02/17/python-tdd-in-emacs</id>
   <content type="html">
&lt;p&gt;Emacs 是著名的万能编辑器，它同样可以用来建立一个非常强大的Python开发环境。&lt;/p&gt;

&lt;p&gt;其实很多 Python 程序员都用 Emacs，有很多不同的组合方式。这里，我们用 iPython 建立一个可以 TDD 的组合。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ipython.org&quot;&gt;iPython&lt;/a&gt; 是一个著名的 Python 扩展环境。通常我们将它视作一个增强的Python Shell。但其实它的能力远不止如此。在其官网上，这样介绍 iPython：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Powerful Python shells (terminal and Qt-based).&lt;/li&gt;
  &lt;li&gt;A web-based notebook with the same core features but support for code, text, mathematical expressions, inline plots and other rich media.&lt;/li&gt;
  &lt;li&gt;Support for interactive data visualization and use of GUI toolkits.&lt;/li&gt;
  &lt;li&gt;Flexible, embeddable interpreters to load into your own projects.&lt;/li&gt;
  &lt;li&gt;Easy to use, high performance tools for parallel computing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里，我们也仅仅用到它的一小部分功能：用它代替默认的Python环境，嵌入到 Emacs 中，作为Emacs的内置Python Shell；以及实现交互式的开发-测试过程。&lt;/p&gt;

&lt;h2 id=&quot;emacs--ipython&quot;&gt;在 Emacs 中嵌入 iPython&lt;/h2&gt;

&lt;p&gt;要在Emacs中嵌入 iPython，需要一个名为 python-mode 的插件。我曾经被这个名字误导，误以为是 Emacs 内置的 python-mode 支持。其实它是&lt;a href=&quot;https://launchpad.net/python-mode&quot;&gt;这个&lt;/a&gt; 。不过我曾经试过在我的工作机上用直接下载的版本配置失败，最终我找了一个可用的版本，冻结在了&lt;a href=&quot;https://bitbucket.org/yinwm/usemacs/src/11b8fb4abd69c9c394c9b537b137cae844b6eb10/raw-elisp/march/macos/site-lisp/python-mode.el?at=default&quot;&gt;usemacs&lt;/a&gt; 项目中。&lt;/p&gt;

&lt;p&gt;最终，我用这样一组代码调用它。这个路径是因为我的 MAC OS 系统中用 mac ports 安装了一个 Python 2.7 。如果你的设置不同，请自行修改。&lt;/p&gt;

&lt;pre class=&quot;language-lisp&quot;&gt;&lt;code&gt;(load-library &quot;python-mode&quot;)
(setq ipython-command &quot;/opt/local/bin/ipython&quot;)
(setq py-python-command &quot;/opt/local/bin/python2.7&quot;)
(setq py-python-command-args '(&quot;--colors&quot; &quot;LightBG&quot;))
(require 'ipython)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当你输入 M-x py-shell，得到的是一个 ipython shell 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/py-shell.png&quot; alt=&quot;py-shell&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它当然，仅仅是这样，它已经很有用，我在编写 Python 代码的时候，经常想要在 Python Shell 里运行一些东西，看看结果，验证一些想法。更不用说 iPython 还可以用来执行系统 Shell。不过它结合一些编码风格和工具操作，还可以更有用。&lt;/p&gt;

&lt;h2 id=&quot;python-tdd&quot;&gt;Python 的TDD&lt;/h2&gt;

&lt;p&gt;Python 有两个内置的 testing 模块，doctest和unittest。unittest 是个比较正规的东西，有很多种不同的编程语言的实现。这里不做赘述了。我们说说 doctest。关于它，官方有一个&lt;a href=&quot;http://docs.python.org/2/library/doctest.html&quot;&gt;详细的文档&lt;/a&gt;。它鼓励程序员一边写代码，一边把验证代码的测试逻辑写下来，而这些代码还可以作为 docstring ，打包在模块中发布，供以后阅读。虽然写起来麻烦点（需要一些啰里巴嗦的修饰字符，是每行），还是很值得做的。&lt;/p&gt;

&lt;p&gt;如果你的 Emacs 环境已经配好了，现在你的 Python 代码保存以后，可以随时按 C-c C-c 执行它，并且，执行结果会返回到你的 py-shell 中。所以，只要在业务代码的最后加这么一行&lt;/p&gt;

&lt;pre class=&quot;language-python&quot;&gt;&lt;code&gt;

if __name__ == &quot;__main__&quot;:
    import doctest
        doctest.testmod()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你就可以在编码过程中随时按下 C-c C-c ，验证你的代码了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/doctesting.png&quot; alt=&quot;doctesting&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;其他配置&lt;/h2&gt;

&lt;p&gt;还有一些配置，我曾经用过，或者是使用过，它们提供了重构、折叠等功能。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;重构&lt;/h3&gt;

&lt;p&gt;Emacs 的 Rope 插件支持python 代码重构，它需要安装 pymacs 。我没有真正用过这个插件，不过有兴趣的朋友可以试下，从我的试用体验来说，比 cedet 要靠谱一些。简单的配置如下：&lt;/p&gt;

&lt;pre class=&quot;language-lisp&quot;&gt;&lt;code&gt;(add-to-list 'load-path &quot;~/.emacs.d/site-lisp/pymacs&quot;)
(require 'pymacs)
(pymacs-load &quot;ropemacs&quot; &quot;rope-&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;代码折叠&lt;/h3&gt;

&lt;p&gt;这个代码是我参考了同行的做法己尝试出来的，后来在mac上python代码写的少，目前就没有激活。在hook 中还有缩进设置。从经验来说，python的缩进最好用4空格。&lt;/p&gt;

&lt;pre class=&quot;language-lisp&quot;&gt;&lt;code&gt;;; 代码折叠设置来自 gb@cs.unc.edu， 感谢他。
(add-hook 'python-mode-hook 'python-mode-hook t)

(defun py-outline-level ()
  (let (buffer-invisibility-spec)
    (save-excursion
      (skip-chars-forward &quot;\t &quot;)
      (current-column))))

(defun python-mode-hook ()
  ; this gets called by outline to deteremine the level. Just use the length of the whitespace
  (custom-set-variables
   '(indent-tabs-mode nil)
   '(tab-width 4)
   '(tab-stop-list nil)
   )
   ; outline uses this regexp to find headers. I match lines with no indent and indented &quot;class&quot;
  ; and &quot;def&quot; lines.
  ; 这里我利用了 Martin Sand Christensen 提供的正则表达式，感谢他。
  (setq outline-regexp &quot;[^ \t]\\|[ \t]*\\(def\\|class\\|if\\|elif\\|else\\|while\\|for\\|try\\|except\\|finally|with\\) &quot;)
  ; enable our level computation
  (setq outline-level 'py-outline-level)
  ; turn on outline mode
  (outline-minor-mode t)
  ; make paren matches visible
  (show-paren-mode 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cedet&quot;&gt;cedet&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cedet.sourceforge.net/&quot;&gt;cedet&lt;/a&gt; 现在已经是 emacs 的内置插件。它有一整套完整的功能，特别是安装了它的组件包ECB以后，很有点eclipse的味道。支持包括C/C++，Python，Java在内的很多语言。不过我是好几年没有用这么重的包啦。何况把它调教顺了也是个看运气的事情。&lt;/p&gt;

&lt;h3 id=&quot;yasnippet&quot;&gt;yasnippet&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/yasnippet/&quot;&gt;yasnippet&lt;/a&gt; 是个相当好用的模板插件，扩展起来比 cedet的同类功能要简单的多。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>How To Create a HTTP PUT use Python</title>
   <link href="http://marchliu.github.com/tech/2013/02/17/how-to-create-a-http-put-use-python"/>
   <updated>2013-02-17T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/tech/2013/02/17/how-to-create-a-http-put-use-python</id>
   <content type="html">
&lt;p&gt;用python发送put请求&lt;/p&gt;

&lt;p&gt;做了一个服务，上传数据时接受put请求，查了一下，客户端代码用Python来写的话非常简单，跟Post基本一致。这里是一个用PUT上传文件数据的例子：&lt;/p&gt;

&lt;pre class=&quot;language-python&quot;&gt;&lt;code&gt;import urllib2  
opener = urllib2.build_opener(urllib2.HTTPHandler)  
with open(&quot;/storage/pic/logo.png&quot;) as f:  
    data=f.read()  
request = urllib2.Request(&quot;http://localhost:8080/logo.png&quot;, data=data)  
request.add_header(&quot;Content-Type&quot;, &quot;image/png&quot;)  
request.get_method = lambda:&quot;PUT&quot;  
url = opener.open(request)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，因为只需要上传文件，我直接在data里放了全文。如果要put一个form上去，可以参见Python库文档中关于urllib2和urlib中如何发送post请求的部分。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Notes of Write Scheme 48 Hours</title>
   <link href="http://marchliu.github.com/notes/2013/02/13/notes-of-write-scheme-48-hours"/>
   <updated>2013-02-13T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/notes/2013/02/13/notes-of-write-scheme-48-hours</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;原子词素解析器&lt;/h2&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;
parseAtom :: Parser LispVal
parseAtom = do first &amp;lt;- letter &amp;lt;|&amp;gt; symbol -- 字母或操作符开头
               rest &amp;lt;- many (letter &amp;lt;|&amp;gt; digit &amp;lt;|&amp;gt; symbol) -- 一到多个
               let atom = [first] ++ rest -- 迭加
               return $ case atom of -- 根据词素解析生成返回的解析值
                          &quot;#t&quot; -&amp;gt; Bool True 
                          &quot;#f&quot; -&amp;gt; Bool False
                          otherwise -&amp;gt; Atom atom

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;练习 2.3.2&lt;/h3&gt;
&lt;p&gt;(Number . read) 如果“.”两边没有空格会出错，应该是错把 Number.read 当 作一个类型了。
看了这个才知道我对 Monad 还是玩的不熟，意识不够：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;
parseNumber :: Parser LispVal
parseNumber = many1 digit &amp;gt;&amp;gt;= (return . Number . read)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;练习 2.3.3&lt;/h3&gt;

&lt;p&gt;这个逃逸字符处理的思路我想到了，但是还是没有意识到 do 模式下 many 和 return 可以这样简洁漂亮的组合：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;escapedChars :: Parser Char
escapedChars = do char '\\' 
                  x &amp;lt;- oneOf &quot;\\\&quot;nrt&quot; 
                  return $ case x of 
                    '\\' -&amp;gt; x
                    '&quot;'  -&amp;gt; x
                    'n'  -&amp;gt; '\n'
                    'r'  -&amp;gt; '\r'
                    't'  -&amp;gt; '\t'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附扩展后的 parseString ，这个倒没大变化：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;parseString :: Parser LispVal
parseString = do char '&quot;'
                 x &amp;lt;- many $ escapedChars &amp;lt;|&amp;gt; noneOf &quot;\&quot;\\&quot;
                 char '&quot;'
                 return $ String x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;练习 2.3.4&lt;/h3&gt;

&lt;p&gt;基本上进制不同的解析是一个力气活。我原本想用 do return case 的方式，但 是后来看还是答案中的每种进制分别解析比较合理，因为逻辑上要区分一些特殊情况。&lt;/p&gt;

&lt;p&gt;这其中需要注意的知识点就是 Numeric 模块中的 readXXX 函数都是返回二元组， 要像如下代码这样取第一个元素出来才是我们需要的答案。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;oct2dig x = fst $ readOct x !! 0
hex2dig x = fst $ readHex x !! 0
bin2dig  = bin2dig' 0
bin2dig' digint &quot;&quot; = digint
bin2dig' digint (x:xs) = let old = 2 * digint + (if x == '0' then 0 else 1) in
                         bin2dig' old xs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;练习 2.3.5&lt;/h3&gt;
&lt;p&gt;这里在函数内部嵌套 do 的技巧值得学习&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;parseCharacter :: Parser LispVal
parseCharacter = do
  try $ string &quot;#\\&quot;
  value &amp;lt;- try (string &quot;newline&quot; &amp;lt;|&amp;gt; string &quot;space&quot;)
           &amp;lt;|&amp;gt; do {x &amp;lt;- anyChar; notFollowedBy alphaNum; return [x]}
  return $ Character $ case value of
                         &quot;space&quot; -&amp;gt; ' '
                         &quot;newline&quot; -&amp;gt; '\n'
                         otherwise -&amp;gt; (value !! 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里开始更多的使用 try ，这个函数我还不熟悉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parseExpr :: Parser LispVal
parseExpr = parseAtom
            &amp;lt;|&amp;gt; parseString
            &amp;lt;|&amp;gt; try parseNumber
            &amp;lt;|&amp;gt; try parseBool
            &amp;lt;|&amp;gt; try parseCharacter
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;练习 2.3.7&lt;/h3&gt;
&lt;p&gt;原文这里似乎有错，我最终用的是 parseNumber 而不是 parseDecimal，这是考 虑到应该允许输入不同进制的复数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parseComplex :: Parser LispVal
parseComplex = do x &amp;lt;- (try parseFloat &amp;lt;|&amp;gt; parseDecimal)
                  char '+' 
                  y &amp;lt;- (try parseFloat &amp;lt;|&amp;gt; parseDecimal)
                  char 'i' 
                  return $ Complex (toDouble x :+ toDouble y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;recursive-parsers&quot;&gt;3.4 Recursive Parsers&lt;/h2&gt;
&lt;p&gt;CLOSED: 2010-11-23 二 01:00
递归解释器这里令人赞叹的利用了 monad then ： CLOSED: 2010-11-23 二 01:00&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;parseDottedList :: Parser LispVal
parseDottedList = do
    head &amp;lt;- endBy parseExpr spaces
    tail &amp;lt;- char '.' &amp;gt;&amp;gt; spaces &amp;gt;&amp;gt; parseExpr
    return $ DottedList head tail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有前趋状态（如某些数据会引用前缀，类似数组则会迭加元素）的时候，需要用 try 。可以确保出错时回溯到出错前的状态。&lt;/p&gt;

&lt;p&gt;在加入了练习补充内容的代码中增加 list 解析过程时，会有编译错误，需要 把 list 的解析器单独取出来。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;parseLst :: Parser LispVal
parseLst = do char '('
              x &amp;lt;- (try parseList) &amp;lt;|&amp;gt; parseDottedList
              char ')'
              return x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后 parseExpr 就成为这样：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;parseExpr :: Parser LispVal
parseExpr = parseAtom
            &amp;lt;|&amp;gt; parseString
            &amp;lt;|&amp;gt; try parseNumber
            &amp;lt;|&amp;gt; try parseRatio
            &amp;lt;|&amp;gt; try parseFloat
            &amp;lt;|&amp;gt; try parseComplex
            &amp;lt;|&amp;gt; try parseBool
            &amp;lt;|&amp;gt; try parseCharacter
            &amp;lt;|&amp;gt; parseQuoted
            &amp;lt;|&amp;gt; parseLst
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本节的几个解析器实现中，递归调用 parseExpr ，实现了整个解析器对递归语 法结构的解析。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;练习 2.4.3&lt;/h3&gt;

&lt;p&gt;在这里 wikibooks 给出了两组不同的实现，一个是实现一种 AnyList。此实现有 一些错误，首先是没有给出 Nil 的实现，我自己尝试做了一个：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;data LispVal = Atom String
             | List [LispVal]
             | DottedList [LispVal] LispVal
             | Number Integer
             | Float Double
             | String String
             | Bool Bool
             | Character Char
             | Ratio Rational
             | Complex (Complex Double)
             | Vector (Array Int LispVal)
             | Nil ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 optionalSpaces 也不存在，实际上应该就是 spaces。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;parseAnyList :: Parser LispVal
parseAnyList = do
  char '('
  spaces
  head &amp;lt;- sepEndBy parseExpr spaces
  tail &amp;lt;- (char '.' &amp;gt;&amp;gt; spaces &amp;gt;&amp;gt; parseExpr) &amp;lt;|&amp;gt; return (Nil ())
  spaces
  char ')'
  return $case tail of
            (Nil ()) -&amp;gt; List head
            otherwise -&amp;gt; DottedList head tail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该页上还给出一种方法是扩展 parseList ，此方法不使用 Nil。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;-- parseList' :: Parser LispVal
parseList' head = do char '.' &amp;gt;&amp;gt; spaces1
                     tail &amp;lt;- parseExpr
                     spaces &amp;gt;&amp;gt; char ')'
                     return $ DottedList head tail

parseList :: Parser LispVal
parseList = do char '(' &amp;gt;&amp;gt; spaces
               head &amp;lt;- parseExpr `sepEndBy` spaces1
               (parseList' head)&amp;lt;|&amp;gt; (spaces &amp;gt;&amp;gt; char ')' &amp;gt;&amp;gt; (return $ List head))
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;此例中仍然遇到在有 choice 运算符（&amp;lt;&lt;/td&gt;
      &lt;td&gt;&amp;gt;） 的情况下无法嵌套 do，于是定义了一个辅助函数。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;evalution-part-1&quot;&gt;Evalution, Part 1&lt;/h2&gt;

&lt;h3 id=&quot;beginnings-of-an-evaluator-primitives&quot;&gt;4.2 Beginnings of an evaluator: Primitives&lt;/h3&gt;
&lt;p&gt;因为 Lisp 族系代码即数据，所以 eval LispVal 变量就是返回 LispVal本身。&lt;/p&gt;

&lt;p&gt;这里使用 @ 运算符，绑定进行局部匹配的变量：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval :: LispVal -&amp;gt; LispVal
eval val@(String _) = val
eval val@(Number _) = val
eval val@(Bool _) = val
eval (List [Atom &quot;quote&quot;, val]) = val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入 eval 后的主函数再次体现了 monad 绑定与 . 运算符的组合技巧。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;main :: IO ()
main = getArgs &amp;gt;&amp;gt;= putStrLn . show . eval . readExpr . (!! 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数中的 ($args) 巧妙使用了 $ 运算符的右结合&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;apply :: String -&amp;gt; [LispVal] -&amp;gt; LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;intermezzo-error-checking--exceptions&quot;&gt;Intermezzo: Error Checking &amp;amp; Exceptions&lt;/h2&gt;

&lt;p&gt;错误处理一章中展示了 Either 的运用。包括 throwError 和 catchError。&lt;/p&gt;

&lt;p&gt;在我们的项目中，用 trapError 方法将 catchError 包装起来。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;trapError action = catchError action (return . show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于正确的执行结果，我们用 extractValue 析出结果值：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;extractValue :: ThrowsError a -&amp;gt; a
extractValue (Right val) = val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eval 中要多处理出错的情况&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval :: LispVal -&amp;gt; ThrowsError LispVal
eval val@(String _) = return val
eval val@(Number _) = return val
eval val@(Bool _) = return val
eval (List [Atom &quot;quote&quot;, val]) = return val
eval (List (Atom func : args)) = mapM eval args &amp;gt;&amp;gt;= apply func
eval badForm = throwError $ BadSpecialForm &quot;Unrecognized special form&quot; badForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数 primitives 只需要修改返回值声明&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;primitives :: [(String, [LispVal] -&amp;gt; ThrowsError LispVal)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;因为我们不需要修改它的每一种实现，只要修改 unaryOp 和 numericBinop 函数即可：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;numericBinop :: (Integer -&amp;gt; Integer -&amp;gt; Integer) -&amp;gt; [LispVal] -&amp;gt; ThrowsError LispVal
numericBinop op singleVal@[_] = throwError $ NumArgs 2 singleVal
numericBinop op params = mapM unpackNum params &amp;gt;&amp;gt;= return . Number . foldl1 op 

unaryOp :: (LispVal -&amp;gt; LispVal) -&amp;gt; [LispVal] -&amp;gt; ThrowsError LispVal
unaryOp f [v] = return $ f v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unpackNum 中，我们对无效值作了异常抛出。如果想要严格类型约束，可以将针对 String 和 List 的实现注释掉。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;unpackNum :: LispVal -&amp;gt; ThrowsError Integer
unpackNum (Number n) = return n
unpackNum (String n) = let parsed = reads n in
                       if null parsed
                          then throwError $ TypeMismatch &quot;number&quot; $ String n
                          else return $ fst ( parsed !! 0)
unpackNum (List [n]) = unpackNum n
unpackNum notNum = throwError $ TypeMismatch &quot;number&quot; notNum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主函数 main 的实现中，通过 trapError 捕获了可能出现的错误&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;main :: IO ()
main = do
  args &amp;lt;- getArgs
  evaled &amp;lt;- return $ liftM show $ readExpr (args !! 0) &amp;gt;&amp;gt;= eval
  putStrLn $ extractValue $ trapError evaled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里对 apply 也做了扩展&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;apply :: String -&amp;gt; [LispVal] -&amp;gt; ThrowsError LispVal
apply func args = maybe (throwError $ NotFunction &quot;Unrecognized primitives function args&quot; func) 
                  ($ args) 
                  (lookup func primitives)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里利用 Either 进行异常和错误处理的方法值得关注。&lt;/p&gt;

&lt;h2 id=&quot;evalution-part-2&quot;&gt;Evalution, Part 2&lt;/h2&gt;

&lt;h3 id=&quot;additional-primitives-partial-application&quot;&gt;Additional Primitives: Partial Application&lt;/h3&gt;

&lt;p&gt;类似 unpackNum ，现在我们也有了 unpackStr 和 unpack Num。 notString 和 notBool 的错误值匹配也是一个技巧。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;unpackStr :: LispVal -&amp;gt; ThrowsError String
unpackStr (String s) = return s
unpackStr (Number s) = return $ show s
unpackStr (Bool s) = return $ show s
unpackStr notString = throwError $ TypeMismatch &quot;string&quot; notString

unpackBool :: LispVal -&amp;gt; ThrowsError Bool
unpackBool (Bool b) = return b
unpackBool notBool = throwError $ TypeMismatch &quot;boolean&quot; notBool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二元逻辑判断的实现。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;boolBinop :: (LispVal -&amp;gt; ThrowsError a) -&amp;gt; (a -&amp;gt; a -&amp;gt; Bool) -&amp;gt; [LispVal] -&amp;gt; ThrowsError LispVal
boolBinop unpacker op args = if length args /= 2
                             then throwError $ NumArgs 2 args
                             else do left &amp;lt;- unpacker $args !! 0
                                     right &amp;lt;- unpacker $args !! 1
                                     return $ Bool $ left `op` right

numBoolBinop = boolBinop unpackNum
strBoolBinop = boolBinop unpackStr
boolBoolBinop = boolBinop unpackBool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;书中给出的代码有些错误，现在完整的指令表是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;primitives :: [(String, [LispVal] -&amp;gt; ThrowsError LispVal)]
primitives = [(&quot;+&quot;, numericBinop (+)),
              (&quot;-&quot;, numericBinop (-)),
              (&quot;*&quot;, numericBinop (*)),
              (&quot;/&quot;, numericBinop div),
              (&quot;=&quot;, numBoolBinop (==)),
              (&quot;&amp;lt;&quot;, numBoolBinop (&amp;lt;)),
              (&quot;&amp;gt;&quot;, numBoolBinop (&amp;gt;)),
              (&quot;/=&quot;, numBoolBinop (/=)),
              (&quot;&amp;gt;=&quot;, numBoolBinop (&amp;gt;=)),
              (&quot;&amp;lt;=&quot;, numBoolBinop (&amp;lt;=)),
              (&quot;&amp;amp;&amp;amp;&quot;, boolBoolBinop (&amp;amp;&amp;amp;)),
              (&quot;||&quot;, boolBoolBinop (||)),
              (&quot;string=?&quot;, strBoolBinop (==)),
              (&quot;string&amp;gt;?&quot;, strBoolBinop (&amp;gt;)),
              (&quot;string&amp;lt;?&quot;, strBoolBinop (&amp;lt;)),
              (&quot;string&amp;lt;=?&quot;, strBoolBinop (&amp;lt;=)),
              (&quot;string&amp;gt;=?&quot;, strBoolBinop (&amp;gt;=)),
              (&quot;mod&quot;, numericBinop mod),
              (&quot;quotient&quot;, numericBinop quot),
              (&quot;remainder&quot;, numericBinop rem),
              (&quot;symbol?&quot;, unaryOp symbolp),
              (&quot;string?&quot;, unaryOp stringp),
              (&quot;number?&quot;, unaryOp numberp),
              (&quot;bool?&quot;, unaryOp boolp),
              (&quot;list?&quot;, unaryOp listp)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pattern-matching-2&quot;&gt;Pattern Matching 2&lt;/h3&gt;
&lt;p&gt;由于 if 语句的实现没有走 primitives ，而是直接取函数名，这里需要将它的 eval 放在前面：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval :: LispVal -&amp;gt; ThrowsError LispVal
eval val@(String _) = return val
eval val@(Number _) = return val
eval val@(Bool _) = return val
eval (List [Atom &quot;quote&quot;, val]) = return val
eval (List [Atom &quot;if&quot;, pred, conseq, alt]) =
    do result &amp;lt;- eval pred
       case result of
         Bool False -&amp;gt; eval alt
         otherwise -&amp;gt; eval conseq
eval (List (Atom func : args)) = mapM eval args &amp;gt;&amp;gt;= apply func
eval badForm = throwError $ BadSpecialForm &quot;Unrecognized special form&quot; badForm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;list-primitives-car-cdr-and-cons&quot;&gt;List Primitives: car, cdr, and cons&lt;/h3&gt;

&lt;p&gt;对于 car 来说，实现代码与匹配规则一一对应：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;(car (a b c)) = a
(car (a)) = a
(car (a b . c)) = a
(car a) = error (not a list)
(car a b) = error (car takes only one argument)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现为：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;car :: [LispVal] -&amp;gt; ThrowsError LispVal
car [List (x : xs)] = return x
car [DottedList (x : xs) _] = return x
car [badArg] = throwError $ TypeMismatch &quot;pair&quot; badArg
car badArgList = throwError $ NumArgs 1 badArgList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理， cdr 规则&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;(cdr (a b c)) = (b c)
(cdr (a b)) = (b)
(cdr (a)) = NIL
(cdr (a b . c)) = (b . c)
(cdr (a . b)) = b
(cdr a) = error (not list)
(cdr a b) = error (too many args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现为：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;cdr :: [LispVal] -&amp;gt; ThrowError LispVal
cdr [List (x:xs)] = return $ List xs
cdr [DottedList (_ :xs) x] = return $ DottedList xs x
cdr [DottedList [xs] x] = return x
cdr [badArg] = throwError $ TypeMismatch &quot;pari&quot; badArg
cdr badArgList = throwError $ NumArgs 1 badArgList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理添加 cons 和 eqv ，在 primitives 加入对应的 KV 对。&lt;/p&gt;

&lt;h3 id=&quot;equal-and-weak-typing-heterogenous-lists&quot;&gt;Equal? and Weak Typing: Heterogenous Lists&lt;/h3&gt;

&lt;p&gt;这里利用了 GHC 的扩展： Existential Types 。使用时需要调用 GHC 的 -fglasgow-exts 选项。&lt;/p&gt;

&lt;p&gt;原文这两行似乎写反了。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;cdr [DottedList [xs] x] = return x
cdr [DottedList (_ :xs) x] = return $ DottedList xs x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这部分展示了一些使用扩展编译选项的类型推导技术，如 forall。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;data Unpacker = forall a . Eq a =&amp;gt; AnyUnpacker (LispVal -&amp;gt; ThrowsError a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;forall 的自动类型推导使得弱类型容器成为可能，进一步允许弱类型比较， 最终落实这个运算的是强和弱判等：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eqv :: [LispVal] -&amp;gt; ThrowsError LispVal
eqv [(Bool arg1), (Bool arg2)] = return $ Bool $ arg1 == arg2
eqv [(Number arg1), (Number arg2)] = return $ Bool $ arg1 == arg2
eqv [(String arg1), (String arg2)] = return $ Bool $ arg1 == arg2
eqv [(Atom arg1), (Atom arg2)] = return $ Bool $ arg1 == arg2
eqv [(DottedList xs x), (DottedList ys y)] = eqv [List $ xs ++ [x], List $ ys ++ [y]]
eqv [(List arg1), (List arg2)] = return $ Bool $ (length arg1 == length arg2) &amp;amp;&amp;amp;
                                 (and $ map eqvPair $ zip arg1 arg2)
                                 where eqvPair (x1, x2) = case eqv [x1, x2] of
                                                            Left err -&amp;gt; False
                                                            Right (Bool val) -&amp;gt; val
eqv [_, _] = return $ Bool False
eqv badArgList = throwError $ NumArgs 2 badArgList

equal :: [LispVal] -&amp;gt; ThrowsError LispVal
equal [arg1, arg2] = do
  primitiveEqual &amp;lt;- liftM or $ mapM (unpackEquals arg1 arg2)
                    [AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool]
  eqvEquals &amp;lt;- eqv [arg1, arg2]
  return $ Bool $ (primitiveEqual || let (Bool x) = eqvEquals in x)

equal badArgList = throwError $ NumArgs 2 badArgList
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;练习 6.4.1&lt;/h3&gt;
&lt;p&gt;这个没太大技术含量，我自己就搞定了：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval (List [Atom &quot;if&quot;, pred, conseq, alt]) =
    do result &amp;lt;- eval pred
       case result of
         Bool True -&amp;gt; eval conseq
         Bool False -&amp;gt; eval alt
         otherwise -&amp;gt; throwError $ TypeMismatch &quot;bool&quot; pred
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;练习 6.4.2&lt;/h3&gt;

&lt;p&gt;对 List 进行强和弱类型比较，这里比我想像的复杂，作者先实现了一个 List 比较函数。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eqvList :: ([LispVal] -&amp;gt; ThrowsError LispVal) -&amp;gt; [LispVal] -&amp;gt; ThrowsError LispVal
eqvList eqvFunc [(List arg1), (List arg2)] = return $ Bool $ (length arg1 == length arg2) &amp;amp;&amp;amp;
                                             (all eqvPair $ zip arg1 arg2)
    where eqvPair (x1, x2) = case eqvFunc [x1, x2] of
                               Left err -&amp;gt; False
                               Right (Bool val) -&amp;gt; val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用它重写了 eqv 和 equal 的 List 实现：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eqv [l1@(List arg1), l2@(List arg2)] = eqvList eqv [l1, l2]
eqv [(DottedList xs x), (DottedList ys y)] = eqv [List $ xs ++ [x], List $ ys ++ [y]]
...
equal [l1@(List arg1), l2@(List arg2)] = eqvList equal [l1, l2]
equal [(DottedList xs x), (DottedList ys y)] = equal [List $ xs++[x], List $ ys++[y]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为haskell的函数模式匹配是按照书写顺序尝试的，所以要注意 函数的顺序。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;练习 6.4.3&lt;/h3&gt;

&lt;p&gt;作者给出了两种不同的 cond 实现，这里我采用了第一种：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval (List ((Atom &quot;cond&quot;):cs)) = do
  b &amp;lt;- (liftM (take 1 . dropWhile f) $ mapM condClause cs) &amp;gt;&amp;gt;= cdr
  car [b] &amp;gt;&amp;gt;= eval
      where condClause (List [Atom &quot;else&quot;, b]) = return $ List [Bool True, b]
            condClause (List [p,b]) = do q &amp;lt;- eval p
                                         case q of
                                           Bool _ -&amp;gt; return $ List [q,b]
                                           _ -&amp;gt; throwError $ TypeMismatch &quot;bool&quot; q
            condClause v = throwError $ TypeMismatch &quot;(pred body)&quot; v
            f = \(List [p,b]) -&amp;gt; case p of
                                   (Bool False) -&amp;gt; True
                                   _ -&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据这个代码，我做出了 case 的实现：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval (List ((Atom &quot;case&quot;):cs)) = do
  b &amp;lt;- (liftM (take 1 . dropWhile f ) $ mapM condClause (tail cs)) &amp;gt;&amp;gt;= cdr
  car [b] &amp;gt;&amp;gt;= eval
      where cond = cs!!0
            condClause (List [Atom &quot;else&quot;, b]) = return $ List [Bool True, b]
            condClause (List [p,b]) = do x &amp;lt;- eval cond
                                         y &amp;lt;- eval p
                                         q &amp;lt;- eqv [x, y]
                                         case q of
                                           Bool _ -&amp;gt; return $ List [q, b]
                                           _ -&amp;gt; throwError $ TypeMismatch &quot;bool&quot; q
            condClause v = throwError $ TypeMismatch &quot;(pred body)&quot; v
            f = \(List [p,b]) -&amp;gt; case p of
                                   (Bool False) -&amp;gt; True
                                   _ -&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此以后的章节，都没有课后习题了。&lt;/p&gt;

&lt;h2 id=&quot;building-a-repl-basic-io&quot;&gt;Building a REPL: Basic I/O&lt;/h2&gt;

&lt;p&gt;书中使用了 Parsec 模块的 try ，所以这里不导入 IO 的 try。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;import IO hiding (try)
IO Monad 本身已经输出状态了，所以这里用 Monad Then 传递：

flushStr :: String -&amp;gt; IO ()
flushStr str = putStr str &amp;gt;&amp;gt; hFlush stdout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 IO Monad then 的运用非常漂亮&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;readPrompt :: String -&amp;gt; IO String
readPrompt prompt = flushStr prompt &amp;gt;&amp;gt; getLine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;摘录： That’s why we write their types using the type variable “m”, and include the type constraint “Monad m =&amp;gt;”&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;until_ :: Monad m =&amp;gt; (a -&amp;gt; Bool) -&amp;gt; m a -&amp;gt; (a -&amp;gt; m ()) -&amp;gt; m ()
until_ pred prompt action = do 
  result &amp;lt;- prompt
  if pred result 
     then return ()
     else action result &amp;gt;&amp;gt; until_ pred prompt action
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;adding-variables-and-assignment-mutable-state-in-haskell&quot;&gt;Adding Variables and Assignment: Mutable State in Haskell&lt;/h2&gt;

&lt;p&gt;State Monad 对于简单的有状态应用非常好用。&lt;/p&gt;

&lt;p&gt;这里使用 state threads，具体而言是 Data.IORef。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;import Data.IORef

type Env = IORef [(String, IORef LispVal)]
建立空环境的 nullEnv 函数：

nullEnv :: IO Env
nullEnv = newIORef []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将异常 lift 为自定义的 IOThrowsError&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;liftThrows :: ThrowsError a -&amp;gt; IOThrowsError a
liftThrows (Left err) = throwError err
liftThrows (Right val) = return val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原文摘录：Methods in typeclasses resolve based on the type of the expression, so throwError and return (members of MonadError and Monad, respectively) take on their IOThrowsError definitions.&lt;/p&gt;

&lt;p&gt;函数 runIOThrows 对 trapError 进行了 IO 包装：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;runIOThrows :: IOThrowsError String -&amp;gt; IO String
runIOThrows action = runErrorT (trapError action) &amp;gt;&amp;gt;= return . extractValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数 lookup 对键值对序列做 key 查询，返回 Maybe value。所以这里利用 const True 做了一个 isBound 查询函数。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;isBound :: Env -&amp;gt; String -&amp;gt; IO Bool
isBound envRef var = readIORef envRef &amp;gt;&amp;gt;= return . maybe False (const True) . lookup var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对 IORef 环境的经典读写操作：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;getVar :: Env -&amp;gt; String -&amp;gt; IOThrowsError LispVal
getVar envRef var = do env &amp;lt;- liftIO $ readIORef envRef
                       maybe (throwError $ UnboundVar &quot;Getting an unbound variable&quot; var)
                             (liftIO . readIORef) (lookup var env)

setVar :: Env -&amp;gt; String -&amp;gt; LispVal -&amp;gt; IOThrowsError LispVal
setVar envRef var value = do env &amp;lt;- liftIO $ readIO envRef
                             maybe (throwError $ UnboundVar &quot;Setting an unboud variable&quot; var)
                                   (liftIO . (flip writeIORef value))
                                   (lookup var env)
                             return value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 bindVars 函数中，利用了 Monadic 管道操作技巧：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;bindVars :: Env -&amp;gt; [(String, LispVal)] -&amp;gt; IO Env
bindVars envRef bindings = readIORef envRef &amp;gt;&amp;gt;= extendEnv bindings &amp;gt;&amp;gt;= newIORef
    where extendEnv bindings env = liftM (++ env) (mapM addBinding bindings)
          addBinding (var, value) = do ref &amp;lt;- newIORef value
                                       return (var, ref)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eval 中传入 env 参数以保持状态，其中 cond 和 case 基本上算重写了一遍……&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval :: Env -&amp;gt; LispVal -&amp;gt; IOThrowsError LispVal
eval env val@(String _) = return val
eval env val@(Number _) = return val
eval env val@(Bool _) = return val
eval env (Atom id) = getVar env id
eval env (List [Atom &quot;quote&quot;, val]) = return val
eval env (List [Atom &quot;if&quot;, pred, conseq, alt]) =
    do result &amp;lt;- eval env pred
       case result of
         Bool True -&amp;gt; eval env conseq
         Bool False -&amp;gt; eval env alt
         otherwise -&amp;gt; throwError $ TypeMismatch &quot;bool&quot; pred
eval env (List ((Atom &quot;cond&quot;):cond:cs)) = do
  result &amp;lt;- condClause env cond
  if (f result) 
     then eval' env result
     else eval env (List ((Atom &quot;cond&quot;):cs))
    where condClause env (List [Atom &quot;else&quot;, b]) = return $ List [Bool True, b]
          condClause env (List [p,b]) = do q &amp;lt;- eval env p
                                           case q of
                                             Bool _ -&amp;gt; return $ List [q,b]
                                             _ -&amp;gt; throwError $ TypeMismatch &quot;bool&quot; q
          condClause env v = throwError $ TypeMismatch &quot;(pred body)&quot; v
          f = \(List [p,b]) -&amp;gt; case p of
                                 (Bool True) -&amp;gt;  True
                                 (Bool False) -&amp;gt; False
          eval' = \env (List [p, b]) -&amp;gt; eval env b                                      
eval env (List ((Atom &quot;case&quot;):c:cond:cs)) = do
  x &amp;lt;- eval env c
  result &amp;lt;- condClause env cond x
  if (f result)
     then eval' env result
     else eval env (List ((Atom &quot;case&quot;):x:cs))
    where condClause env (List [Atom &quot;else&quot;, b]) x = return $ List [Bool True, b]
          condClause env (List [p,b]) x = do y &amp;lt;- eval env p
                                             q &amp;lt;- return $ eqv [x, y]
                                             (\e -&amp;gt; let v = extractValue e
                                                    in case v of
                                                         Bool _ -&amp;gt; return $List [v, b]
                                                         _ -&amp;gt; throwError $ TypeMismatch &quot;bool&quot; v) q
          condClause env v x = throwError $ TypeMismatch &quot;(pred body)&quot; v
          f = \(List [p,b]) -&amp;gt; case p of
                                 (Bool False) -&amp;gt; False
                                 _ -&amp;gt; True
          eval' = \env (List [p, b]) -&amp;gt; eval env b
eval env (List [Atom &quot;set!&quot;, Atom var, form]) =
    eval env form &amp;gt;&amp;gt;= setVar env var
eval env (List [Atom &quot;define&quot;, Atom var, form]) =
    eval env form &amp;gt;&amp;gt;= defineVar env var
eval env (List (Atom func : args)) = mapM (eval env) args &amp;gt;&amp;gt;= liftThrows.apply func
eval env badForm = throwError $ BadSpecialForm &quot;Unrecognized special form&quot; badForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为要保持环境，单行语句和 REPL 的执行函数分成了两个：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;runOne :: String -&amp;gt; IO ()
runOne expr = nullEnv &amp;gt;&amp;gt;= flip evalAndPrint expr

runRepl :: IO ()
runRepl = nullEnv &amp;gt;&amp;gt;= until_ (== &quot;quit&quot;) (readPrompt &quot;Lisp&amp;gt;&amp;gt;&amp;gt; &quot;) . evalAndPrint

main :: IO ()
main = do args &amp;lt;- getArgs
          case length args of
              0 -&amp;gt; runRepl
              1 -&amp;gt; runOne $ args !! 0
              otherwise -&amp;gt; putStrLn &quot;Program takes only 0 or 1 argument&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;defining-scheme-functions-closures-and-environments&quot;&gt;Defining Scheme Functions: Closures and Environments&lt;/h2&gt;

&lt;p&gt;代码示例基本没什么错误
函数的定义和函数执行是两个相关的内容。&lt;/p&gt;

&lt;p&gt;扩展后的 LispVal：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;data LispVal = Atom String
             | List [LispVal]
             | DottedList [LispVal] LispVal
             | Number Integer
             | Float Double
             | String String
             | Bool Bool
             | Character Char
             | Ratio Rational
             | Complex (Complex Double)
             | Vector (Array Int LispVal)
             | PrimitiveFunc ([LispVal] -&amp;gt; ThrowsError LispVal)
             | Func {params :: [String], vararg :: (Maybe String),
                     body :: [LispVal], closure :: Env}
             | Nil ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数定义涉及参数名、参数列、函数体和闭包。新的 apply 实现了函数定义和执行：&lt;/p&gt;

&lt;p&gt;函数解析代码中先判定了形参与实参是否一致（如果没有指定动态参数， 给出的实参个数又与形参不同，则报错）。然后利用 curry 方法生成 该函数的函数实现。在各操作（绑定作用域、参数和解析函数体）的过程 中，以 Monad bind 串起各部分。注意这里 bindVars 接受的第一 个函数是 closure ，在 eval 中我们可以看到 closure 是 外部的 env。在传值过程中，env 复制为函数 closure。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;apply :: LispVal -&amp;gt; [LispVal] -&amp;gt; IOThrowsError LispVal
apply (PrimitiveFunc func) args = liftThrows $ func args
apply (Func params varargs body closure) args =
    if num params /= num args &amp;amp;&amp;amp; varargs == Nothing
       then throwError $ NumArgs (num params) args
       else (liftIO $ bindVars closure $ zip params args) &amp;gt;&amp;gt;= bindVarArgs varargs &amp;gt;&amp;gt;= evalBody
    where remainingArgs = drop (length params) args
          num = toInteger . length
          evalBody env  = liftM last $ mapM (eval env) body
          bindVarArgs arg env = case arg of
                                  Just argName -&amp;gt; liftIO $ bindVars env [(argName, List $ remainingArgs)]
                                  Nothing -&amp;gt; return env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数相关的 eval 实现。&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;eval env (List (Atom &quot;define&quot; : List (Atom var : params) : body)) =
    makeNormalFunc env params body &amp;gt;&amp;gt;= defineVar env var
eval env (List (Atom &quot;define&quot; : DottedList (Atom var : params) varargs : body)) =
    makeVarargs varargs env params body &amp;gt;&amp;gt;= defineVar env var
eval env (List (Atom &quot;lambda&quot; : List params : body)) =
    makeNormalFunc env params body
eval env (List (Atom &quot;lambda&quot; : DottedList params varargs : body)) =
    makeVarargs varargs env params body
eval env (List (Atom &quot;lambda&quot; : varargs@(Atom _) : body)) =
    makeVarargs varargs env [] body
eval env (List (function : args)) = do func &amp;lt;- eval env function
                                       argVals &amp;lt;- mapM (eval env) args
                                       apply func argVals
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 eval 中使用到的函数构造代码：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;makeFunc varargs env params body = return $ Func (map showVal params) varargs body env
makeNormalFunc = makeFunc Nothing
makeVarargs = makeFunc . Just . showVal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;环境初始化代码进行了进一步的扩展，将所有的 primitive 封装为函数。这部分实现的简洁有力：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;primitiveBindings :: IO Env
primitiveBindings = nullEnv &amp;gt;&amp;gt;= (flip bindVars $ map makePrimitiveFunc primitives)
    where makePrimitiveFunc (var, func) = (var, PrimitiveFunc func)

runOne :: String -&amp;gt; IO ()
runOne expr = primitiveBindings &amp;gt;&amp;gt;= flip evalAndPrint expr

runRepl :: IO ()
runRepl = primitiveBindings &amp;gt;&amp;gt;= until_ (== &quot;quit&quot;) (readPrompt &quot;Lisp&amp;gt;&amp;gt;&amp;gt; &quot;) . evalAndPrint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后这几章的内容中，数次出现了 flip 操作。&lt;/p&gt;

&lt;h2 id=&quot;creating-io-primitives-file-io&quot;&gt;Creating IO Primitives: File I/O&lt;/h2&gt;

&lt;p&gt;这一章代码没什么争议
因为输入的参数不同（数组和数值的区别），io 的指令集是独立实现的：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;ioPrimitives :: [(String, [LispVal] -&amp;gt; IOThrowsError LispVal)]
ioPrimitives = [(&quot;apply&quot;, applyProc),
                (&quot;open-input-file&quot;, makePort ReadMode),
                (&quot;open-output-file&quot;, makePort WriteMode),
                (&quot;close-input-port&quot;, closePort),
                (&quot;close-output-port&quot;, closePort),
                (&quot;read&quot;, readProc),
                (&quot;write&quot;, writeProc),
                (&quot;read-contents&quot;, readContents),
                (&quot;read-all&quot;, readAll)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其底层的文件操作都是对 haskell 库的浅封装：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;applyProc :: [LispVal] -&amp;gt; IOThrowsError LispVal
applyProc [func, List args] = apply func args
applyProc (func : args) = apply func args

readProc :: [LispVal] -&amp;gt; IOThrowsError LispVal
readProc [] = readProc [Port stdin]
readProc [Port port] = (liftIO $ hGetLine port) &amp;gt;&amp;gt;= liftThrows . readExpr

writeProc :: [LispVal] -&amp;gt; IOThrowsError LispVal
writeProc [obj] = writeProc [obj, Port stdout]
writeProc [obj, Port port] = liftIO $ hPrint port obj &amp;gt;&amp;gt; (return $ Bool True)

readContents :: [LispVal] -&amp;gt; IOThrowsError LispVal
readContents [String filename] = liftM String $ liftIO $ readFile filename

makePort :: IOMode -&amp;gt; [LispVal] -&amp;gt; IOThrowsError LispVal
makePort mode [String filename] = liftM Port $ liftIO $ openFile filename mode

closePort :: [LispVal] -&amp;gt; IOThrowsError LispVal
closePort [Port port] = liftIO $ hClose port &amp;gt;&amp;gt; (return $ Bool True)
closePort _ = return $ Bool False

load :: String -&amp;gt; IOThrowsError [LispVal]
load filename = (liftIO $ readFile filename) &amp;gt;&amp;gt;= liftThrows . readExprList

readAll :: [LispVal] -&amp;gt; IOThrowsError LispVal
readAll [String filename] = liftM List $ load filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了处理单语句和多语句，代码解析也进行了抽象，分别实现具体的操作&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;readOrThrow :: Parser a -&amp;gt; String -&amp;gt; ThrowsError a
readOrThrow parser input = case parse parser &quot;lisp&quot; input of
                             Left err -&amp;gt; throwError $ Parser err
                             Right val -&amp;gt; return val

readExpr = readOrThrow parseExpr
readExprList = readOrThrow (endBy parseExpr spaces)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;环境初始化，引入指令集的实现，针对 IO 作了扩展：&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;primitiveBindings :: IO Env
primitiveBindings = nullEnv &amp;gt;&amp;gt;= (flip bindVars $ map (makeFunc IOFunc) ioPrimitives
                                        ++ map (makeFunc PrimitiveFunc) primitives)
    where makeFunc constructor (var, func) = (var, constructor func)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;交互过程做了相应的调整&lt;/p&gt;

&lt;pre class=&quot;language-haskell&quot;&gt;&lt;code&gt;runOne :: [String] -&amp;gt; IO ()
runOne args = do
  env &amp;lt;- primitiveBindings &amp;gt;&amp;gt;= flip bindVars [(&quot;args&quot;, List $ map String $ drop 1 args)]
  (runIOThrows $ liftM show $ eval env (List [Atom &quot;load&quot;, String (args !! 0)]))
              &amp;gt;&amp;gt;= hPutStrLn stderr

runRepl :: IO ()
runRepl = primitiveBindings &amp;gt;&amp;gt;= until_ (== &quot;quit&quot;) (readPrompt &quot;Lisp&amp;gt;&amp;gt;&amp;gt; &quot;) . evalAndPrint

main :: IO ()
main = do args &amp;lt;- getArgs
          if null args then runRepl else runOne $ args
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;towards-a-standard-library-fold-and-unfold&quot;&gt;Towards a Standard Library: Fold and Unfold&lt;/h2&gt;

&lt;p&gt;这一章只有 scheme 的代码和内置库实现，留待想要学习 sheme 语言的时候深入。&lt;/p&gt;

&lt;h2 id=&quot;conclusion--further-resources&quot;&gt;Conclusion &amp;amp; Further Resources&lt;/h2&gt;

&lt;p&gt;附录跳过&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html&quot;&gt;原书在线阅读&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Answers&quot;&gt;参考答案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;时间和精力有限，我没有认真的去做每一道题，而仅仅是把在线答案中的每一个 调试验证了一遍。示例中还是有一些小错误的，如果只是复制，无法顺利编译运 行，有一些我在笔记中有提到，附件中是我自己的练习代码。&lt;/p&gt;

&lt;p&gt;从我个人体验来讲，用 ghci 来练习，要比编译后调试要快捷得多。不过从第 六章 Evalution 2 开始，需要 -XExistentialQuantification 选项。 如果你和我一样使用 emacs 的 ghci 集成 shell ，没办法用 ghci -XExistentialQuantification 形式启动交互环境，可以在 ghci 中执行 :set -XExistentialQuantification 加载这一选项。&lt;/p&gt;

&lt;p&gt;这本书不应该作为 Haskell 学习的第一本书，甚至也不一定应该是第二本书。 学习此书最好有初步的 lisp/scheme 知识。&lt;/p&gt;

&lt;p&gt;我的阅读过程还是比较粗糙的，建议在遇到不能完全理解的地方，用 ghci 调试 一下。&lt;/p&gt;

&lt;p&gt;作为第一本书，&lt;a href=&quot;http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf&quot;&gt;Yet Another Haskell Tutorial&lt;/a&gt; 更系统，内容循序渐进。&lt;/p&gt;

&lt;p&gt;作为第二本书，&lt;a href=&quot;http://www.realworldhaskell.org/&quot;&gt;Real World Haskell&lt;/a&gt; 更有实践性，曲线比较平滑。&lt;/p&gt;

&lt;p&gt;本书应该作为从初阶到中阶的一本阶段总结辅导。或者，除非你有 scheme/lisp 基础，对第一本书也学的比较顺利……&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>About</title>
   <link href="http://marchliu.github.com/others/2013/02/12/about"/>
   <updated>2013-02-12T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/others/2013/02/12/about</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;人品保证这个不坑&lt;/h2&gt;

&lt;p&gt;如果我还有人品这种东西……&lt;/p&gt;

&lt;p&gt;不过，我不保证：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用中文还是英文写文章&lt;/li&gt;
  &lt;li&gt;某个连载会不会完 &lt;/li&gt;
  &lt;li&gt;过去其它地方发的文章会不会全迁过来&lt;/li&gt;
  &lt;li&gt;过去的观点现在是否还坚持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我会保证：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽量不转载，转载或翻译会给出出处&lt;/li&gt;
  &lt;li&gt;翻译会给出英文原文&lt;/li&gt;
  &lt;li&gt;尽量有趣&lt;/li&gt;
  &lt;li&gt;尽量不说傻话&lt;/li&gt;
  &lt;li&gt;尽量不无聊&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>How To Read Mathematics 如何阅读数学</title>
   <link href="http://marchliu.github.com/translation/2013/02/08/how-to-read-mathematics"/>
   <updated>2013-02-08T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/translation/2013/02/08/how-to-read-mathematics</id>
   <content type="html">
&lt;p&gt;This article is part of the book Rediscovering Mathematics, which is due out in early 2011. - Rediscovering Mathematics: Patriot Ledger&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mathematics is “a language that can neither be read nor understood without initiation.”
未经启蒙的话，数学是门既不可读又无法理解的语言。 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A reading protocol is a set of strategies that a reader must use in order to benefit fully from reading the text. Poetry calls for a different set of strategies than fiction, and fiction a different set than non-fiction. It would be ridiculous to read fiction and ask oneself what is the author’s source for the assertion that the hero is blond and tanned; it would be wrong to read non-fiction and not ask such a question. This reading protocol extends to a viewing or listening protocol in art and music. Indeed, much of the introductory course material in literature, music and art is spent teaching these protocols.&lt;/p&gt;

&lt;p&gt;阅读的原则是一些可以让读者受益的方法。诗歌和小说有不同的方法，小说与非 虚构有不同的方法。读了小说以后就要求证主人公的原型和作者写的一样金发碧眼而 且有褐色皮肤就太可笑了。读了非虚构的文学以后不对这些有质疑也不对。这是 欣赏艺术和音乐的原则。的确，很多文学、音乐和艺术作品已经过时了，不再适 合这个原则。&lt;/p&gt;

&lt;p&gt;Mathematics has a reading protocol all its own, and just as we learn to read literature, we should learn to read mathematics. Students need to learn how to read mathematics, in the same way they learn how to read a novel or a poem, listen to music, or view a painting. Ed Rothstein’s book, Emblems of Mind, a fascinating book emphasizing the relationship between mathematics and music, touches implicitly on the reading protocols for mathematics.&lt;/p&gt;

&lt;p&gt;数学有其自己的阅读原则，就像我们学习文学阅读，我们也应该学习数学阅读。 就像学生需要学会如何阅读长篇小说和诗歌，学会听音乐和观赏画作，他们也同 样需要学会阅读数学。Ed Rothstein 的《心灵的象征》，是本迷人的书，强调 数学和音乐之间的关系，触及了数学阅读的原则。&lt;/p&gt;

&lt;p&gt;When we read a novel we become absorbed in the plot and characters. We try to follow the various plot lines and how each affects the development of the characters. We make sure that the characters become real people to us, both those we admire and those we despise. We do not stop at every word, but imagine the words as brushstrokes in a painting. Even if we are not familiar with a particular word, we can still see the whole picture. We rarely stop to think about individual phrases and sentences. Instead, we let the novel sweep us along with its flow and carry us swiftly to the end. The experience is rewarding, relaxing and thought provoking.&lt;/p&gt;

&lt;p&gt;当我们阅读长篇小说时，会被情节和人物吸引。我们试图理解情节线索，搞明白 它们如何影响人物的各方面。我们会想像那些被我们赞赏和厌恶的人物成为真实 存在的人物。我们欲罢不能，用文字在脑海中描述图景。甚至我们不必关注每个 具体的字眼，仍可以洞察整个画卷。我们很少停下来思考某个段落或句子。相反，我们任由小说将我们丢入剧情的激流，裹挟着我们直达结尾。这种体验很棒，放松而剌激。&lt;/p&gt;

&lt;p&gt;Novelists frequently describe characters by involving them in well-chosen anecdotes, rather than by describing them by well-chosen adjectives. They portray one aspect, then another, then the first again in a new light and so on, as the whole picture grows and comes more and more into focus. This is the way to communicate complex thoughts that defy precise definition.&lt;/p&gt;

&lt;p&gt;小说家经常将角色置于精心构造的桥段中以描写他们，而不是用精挑细选的形容 词来表达。他们描述一个面孔，然后是另一个，然后第一个又出现在新的瞬间。 反复如此直到整个画卷越来越清晰。这是不使用精确定义而表达复杂含义的方法。&lt;/p&gt;

&lt;p&gt;Mathematical ideas are by nature precise and well defined, so that a precise description is possible in a very short space. Both a mathematics article and a novel are telling a story and developing complex ideas, but a math article does the job with a tiny fraction of the words and symbols of those used in a novel. The beauty in a novel is in the aesthetic way it uses language to evoke emotions and present themes which defy precise definition. The beauty in a mathematics article is in the elegant efficient way it concisely describes precise ideas of great complexity.&lt;/p&gt;

&lt;p&gt;数学思想天然就是定义完全而精确的，故可以在很短的容量中精确的描述。数学 论文和小说都是讲述一个故事以展显复杂的思想，但是数学论文只用小说词语和 符号的一小部分数量就完成这件事。小说之美在于优美的运用语言来唤起情绪但 拒绝精确定义。数学之美在于它优雅高效的表达方式，简洁的描述出复杂事物中 精确的思想。&lt;/p&gt;

&lt;p&gt;What are the common mistakes people make in trying to read mathematics? How can these mistakes be corrected?&lt;/p&gt;

&lt;p&gt;想要阅读数学的人通常会犯什么错误？如何避免它们？&lt;/p&gt;

&lt;h2 id=&quot;dont-miss-the-big-picture-&quot;&gt;Don’t Miss the Big Picture 不要忘记大局&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;“Reading Mathematics is not at all a linear experience … Understanding the text requires cross references, scanning, pausing and revisiting”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;数学阅读不是线性的体验……理解文本需要交叉引用、扫读、停顿和重。&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Don’t assume that understanding each phrase, will enable you to understand the whole idea. This is like trying to see a portrait painting by staring at each square inch of it from the distance of your nose. You will see the detail, texture and color but miss the portrait completely. A math article tells a story. Try to see what the story is before you delve into the details. You can go in for a closer look once you have built a framework of understanding. Do this just as you might reread a novel.&lt;/p&gt;

&lt;p&gt;不要想当然的认为理解每一个段落会有助于你理解整个思想。这就像想要从每一 个平方英寸入手去尝试看清你鼻尖前的一幅肖像油画。你可以看到细节，纹理和 颜色，但是看不到整个肖像。每篇数学论文都讲一个故事。在你深入细节前，尝 试了解故事。你可以在构建起理解的框架后再深入。这就像你读小说时一样。&lt;/p&gt;

&lt;h2 id=&quot;dont-be-a-passive-reader-&quot;&gt;Don’t be a Passive Reader 不要做一个被动的读者&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;“A three-line proof of a subtle theorem is the distillation of years of activity.  Reading mathematics… involves a return to the thinking that went into the writing”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;某个巧妙的定理的三段证明可以是经年思考的升华。阅读数学……将我们带回写 下它们的那个时刻。 &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Explore examples for patterns. Try special cases.&lt;/p&gt;

&lt;p&gt;探索模式的示例，尝试特定的例子。&lt;/p&gt;

&lt;p&gt;A math article usually tells only a small piece of a much larger and longer story. The author usually spends months discovering things, and going down blind alleys. At the end, he organizes it all into a story that covers up all the mistakes (and related motivation), and presents the completed idea in clean neat flow. The way to really understand the idea is to re-create what the author left out. Read between the lines.&lt;/p&gt;

&lt;p&gt;数学论文通常只讲述更大更长的故事中的一个片段。作者通常花费几个月发现事 物，走入死胡同。最终，他将这一切写入一个故事，讲述所有的错误（及相关的 动机），然后在清晰的情节中给出完整的思想。阅读字里行间，这种方式确实可 以重现作者表达的思想。&lt;/p&gt;

&lt;p&gt;Mathematics says a lot with a little. The reader must participate. At every stage, he/she must decide whether or not the idea being presented is clear. Ask yourself these questions:&lt;/p&gt;

&lt;p&gt;数学在很短的篇幅里讲述很多。读者必须参与其中。在每个章节，他／她必须判 断是否明白了其中的思想。自省以下的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Why is this idea true?
为什么这个想法是对的？&lt;/li&gt;
  &lt;li&gt;Do I really believe it?
我是否确信它？&lt;/li&gt;
  &lt;li&gt;Could I convince someone else that it is true?
我能说服别人也信服它吗？&lt;/li&gt;
  &lt;li&gt;Why didn’t the author use a different argument?
为什么作者没有用一个不同的论据？&lt;/li&gt;
  &lt;li&gt;Do I have a better argument or method of explaining the idea?
我有没有一个更好的论据或方法来说明这个思想？&lt;/li&gt;
  &lt;li&gt;Why didn’t the author explain it the way that I understand it?
为什么作者不用我理解到的方式去阐述它？&lt;/li&gt;
  &lt;li&gt;Is my way wrong?
我的方法错了吗？&lt;/li&gt;
  &lt;li&gt;Do I really get the idea?
我确实理解这些方法了吗？&lt;/li&gt;
  &lt;li&gt;Am I missing some subtlety?
我是否搞错了某些细节？&lt;/li&gt;
  &lt;li&gt;Did this author miss a subtlety?
作者是否错失了某些细节？&lt;/li&gt;
  &lt;li&gt;If I can’t understand the point, perhaps I can understand a similar
but simpler idea?
如果我不能理解这个观点，我是否能理解类似的更简单的思想？&lt;/li&gt;
  &lt;li&gt;Which simpler idea?
哪个思想更简单？&lt;/li&gt;
  &lt;li&gt;Is it really necessary to understand this idea?
对于理解这个思想，它确实是必要的吗？&lt;/li&gt;
  &lt;li&gt;Can I accept this point without understanding the details of why it
is true?
在不理解它成立的细节依据时，我能接受这个观点吗？&lt;/li&gt;
  &lt;li&gt;Will my understanding of the whole story suffer from not
understanding why the point is true?
在容忍一些我不理解的内容后，我能理解整个故事吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Putting too little effort into this participation is like reading a novel without concentrating. After half an hour, you wake up to realize the pages have turned, but you have been daydreaming and don’t remember a thing you read.&lt;/p&gt;

&lt;p&gt;在参与过程中投入的努力太少，就会像阅读一本没有精要的长篇小说。半小时过 去，你清醒过来，意识到翻页了，但是完全不记得刚刚的白日梦中读到了什么。&lt;/p&gt;

&lt;h2 id=&quot;dont-read-too-fast-&quot;&gt;Don’t Read Too Fast 别读的太快&lt;/h2&gt;

&lt;p&gt;Reading mathematics too quickly results in frustration. A half hour of concentration in a novel might net the average reader 20-60 pages with full comprehension, depending on the novel and the experience of the reader. The same half hour in a math article buys you 0-10 lines depending on the article and how experienced you are at reading mathematics. There is no substitute for work and time. You can speed up your math reading skill by practicing, but be careful. Like any skill, trying too much too fast can set you back and kill your motivation. Imagine trying to do an hour of high-energy aerobics if you have not worked out in two years. You may make it through the first class, but you are not likely to come back. The frustration from seeing the experienced class members effortlessly do twice as much as you, while you moan the whole next day from soreness, is too much to take.&lt;/p&gt;

&lt;p&gt;数学阅读过快会带来挫败感。在阅读小说时，视读者的经历和小说而异，半小时内可以 读 20 到 60 页并完全理解。同样阅读数学论文半小时，视你数学阅读的经验和 论文而异，可以读 0 到 10行。这些劳作和时间无可取代。但是要记住，你可以 通过实践提升数学阅读技巧，加快速度。和任何其它技巧一样，如果你做的过快， 可能会徒劳无功，浪费自己的积极性。设想一下，如果你兩年没有做过高强度的健 身操，现在来它一个小时。你也许做的一极棒，但是不会想再来一次。当你第二 天在痛苦中抱怨的时候，老兵级别的轻松达到你的两倍进度，这是你望尘莫及的 程度。&lt;/p&gt;

&lt;p&gt;For example, consider the following theorem from Levi Ben Gershon’s manuscript Maaseh Hoshev (The Art of Calculation), written in 1321.&lt;/p&gt;

&lt;p&gt;例如，考虑 Levi Ben Gershon 1321 年的 Maaseh Hoshev 手稿（计算的艺术）。&lt;/p&gt;

&lt;p&gt;“When you add consecutive numbers starting with 1, and the number of numbers you add is odd, the result is equal to the product of the middle number among them times the last number.” It is natural for modern day mathematicians to write this as:&lt;/p&gt;

&lt;p&gt;“当你从 1 开始连续的累加数值，累加奇数个，其结果等于中位数与最后一个数 的积。”现代数学写作:&lt;/p&gt;

&lt;p&gt;A reader should take as much time to unravel the two-inch version as he would to unravel the two-sentence version. An example of Levi’s theorem is that 1 + 2 + 3 + 4 + 5 = 3×5.&lt;/p&gt;

&lt;p&gt;读者花在理解两英寸版本上的时间应该与两句版本一样。例如，Levi’s 定理的 一个示例如下： 1 + 2 + 3 + 4 + 5 = 3×5 。&lt;/p&gt;

&lt;p&gt;Make the Idea your Own 建立你自己的思想
The best way to understand what you are reading is to make the idea your own. This means following the idea back to its origin, and rediscovering it for yourself. Mathematicians often say that to understand something you must first read it, then write it down in your own words, then teach it to someone else. Everyone has a different set of tools and a different level of “chunking up” complicated ideas. Make the idea fit in with your own perspective and experience.&lt;/p&gt;

&lt;p&gt;阅读时最好的理解方式是建立你自己的思想。这意味着追寻思想的脉络，重 新发现它。数学家们经常讲你要理解某事就要先去读它，然后用自己的语言写下 来，再去向别人传授。每个人都有独特的工具集，“归纳”复杂事物的层次也不同。 让这个思想符合你自己的想法和体验。&lt;/p&gt;

&lt;p&gt;“When I use a word, it means just what I choose it to mean”&lt;/p&gt;

&lt;p&gt;“当我选择一个词语，它就是我为它选择的含义”&lt;/p&gt;

&lt;p&gt;(Humpty Dumpty to Alice in Through the Looking Glass by Lewis Carroll)&lt;/p&gt;

&lt;p&gt;“The meaning is rarely completely transparent, because every symbol or word already represents an extraordinary condensation of concept and reference”&lt;/p&gt;

&lt;p&gt;这意味着很少有完整的说明，因为每一个符号和词语都代表了一个章节的缩写或引用参考 &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;A well-written math text will be careful to use a word in one sense only, making a distinction, say, between combination and permutation (or arrangement). A strict mathematical definition might imply that “yellow rabid dog” and “rabid yellow dog” are different arrangements of words but the same combination of words. Most English speakers would disagree. This extreme precision is utterly foreign to most fiction and poetry writing, where using multiple words, synonyms, and varying descriptions is de rigueur.&lt;/p&gt;

&lt;p&gt;书写良好的数学文本会非常注意用语无岐义，区分明显，如组合与排列（或放 置）。严格的数学定义可以说明“黄疯狗”和“疯黄狗”是不同的词语排列方 式，但它们是同样的组合。大多数说英语的人都不会同意这个。这种极端精确的 用法对大多数小说和诗绝对都是陌生的，它们出于礼仪需要使用复合词，同义词 和各种描述。&lt;/p&gt;

&lt;p&gt;A reader is expected to know that an absolute value is not about some value that happens to be absolute, nor is a function about anything functional.&lt;/p&gt;

&lt;p&gt;对读者来说，他应该知道绝对值不是绝对会出现的一些值，也不是某种有实用价 值的函数。&lt;/p&gt;

&lt;p&gt;A particular notorious example is the use of “It follows easily that” and equivalent constructs. It means something like this:&lt;/p&gt;

&lt;p&gt;有个特别臭名昭著的例子是滥用“显然可以得到”及其等价物，它相当于下面 的意思：&lt;/p&gt;

&lt;p&gt;One can now check that the next statement is true with a certain amount of essentially mechanical, though perhaps laborious, checking. I, the author, could do it, but it would use up a large amount of space and perhaps not accomplish much, since it’d be best for you to go ahead and do the computation to clarify for yourself what’s going on here.  I promise that no new ideas are involved, though of course you might need to think a little in order to find just the right combination of good ideas to apply.&lt;/p&gt;

&lt;p&gt;现在可以用一系列明确的步骤机械的判明下一表述的正确性，即使可能是很繁重 的步骤。我，即作者，可以做到它，但是它可能会占用大量的空间，而这可能无 法接受，而由你来完成这些计算，去验证它更好。我承诺不会有什么新的思想再 引入进来，当然你还是需要稍动一下脑子，把好点子正确的组合起来。&lt;/p&gt;

&lt;p&gt;In other words, the construct, when used correctly, is a signal to the reader that what’s involved here is perhaps tedious and even difficult, but involves no deep insights. The reader is then free to decide whether the level of understanding he/she desires requires going through the details or warrants saying “Okay, I’ll accept your word for it.”&lt;/p&gt;

&lt;p&gt;另一方面，使用得当的话，这种形式很有用。它给读者一个提示，这里可以参与 进来，也许很复杂，很困难，但是不需要更深入的洞见。读者可以自己决定其理 解层次，可以深入细节，也可以讲“OK，我相信你的说法。”&lt;/p&gt;

&lt;p&gt;Now, regardless of your opinion about whether that construct should be used in a particular situation, or whether authors always use it correctly, you should understand what it is supposed to mean. “It follows easily that” does not mean&lt;/p&gt;

&lt;p&gt;于是，不管你怎么想，要么这种形式用在非常特殊的情况，要么作者总是很得体 的使用它，你应该能理解它的含义。“显然可以得到”不意味着&lt;/p&gt;

&lt;p&gt;if you can’t see this at once, you’re a dope,&lt;/p&gt;

&lt;p&gt;如果你一下子看不懂，你就是个笨蛋，&lt;/p&gt;

&lt;p&gt;neither does it mean&lt;/p&gt;

&lt;p&gt;也不表示&lt;/p&gt;

&lt;p&gt;this shouldn’t take more than two minutes,&lt;/p&gt;

&lt;p&gt;这玩意儿用不了两分钟就能看明白，&lt;/p&gt;

&lt;p&gt;but a person who doesn’t know the lingo might interpret the phrase in the wrong way, and feel frustrated. This is apart from the issue that one person’s tedious task is another person’s challenge, so the author must correctly judge the audience.&lt;/p&gt;

&lt;p&gt;但是不懂这些隐语的人会因为误解了内容而感到挫折。甲之废话，乙之真言，这 一直是争议所在，作者要恰当的评估读者的水平。&lt;/p&gt;

&lt;p&gt;Know Thyself 了解你自己
Texts are written with a specific audience in mind. Make sure that you are the intended audience, or be willing to do what it takes to become the intended audience.&lt;/p&gt;

&lt;p&gt;文章总是为由假想中的读者写就，请确认你正是这样的读者，或者至少想要变成一个 适宜的读者。&lt;/p&gt;

&lt;p&gt;T.S.Eliot’s&lt;/p&gt;

&lt;p&gt;A Song for Simeon:&lt;/p&gt;

&lt;p&gt;西面颂歌 &lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Lord, the Roman hyacinths are blooming in bowls and
The winter sun creeps by the snow hills;
The stubborn season has made stand.
My life is light, waiting for the death wind,L
Like a feather on the back of my hand.
Dust in sunlight and memory in corners
Wait for the wind that chills towards the dead land.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, Eliot’s poem pretty much assumes that its readers are going to either know who Simeon was or be willing to find out. It also assumes that its reader will be somewhat experienced in reading poetry and/or is willing to work to gain such experience. He assumes that they will either know or investigate the allusions here. This goes beyond knowledge of things like who Simeon was. For example, why are the hyacinths “Roman?” Why is that important?&lt;/p&gt;

&lt;p&gt;举个例子，艾略特这首诗就做了不少假设：读者要么知道西面是谁，要么愿意去 了解他是谁；读者要么有一定诗歌鉴赏基础，要么愿意提高这方面的能力；读者 要么知晓诗中的典故，要么愿意研究个中精妙，比如为什么是“罗马”风信子， 为什么这个意象很重要。&lt;/p&gt;

&lt;p&gt;Elliot assumes that the reader will read slowly and pay attention to the images: he juxtaposes dust and memory, relates old age to winter, compares waiting for death with a feather on the back of the hand, etc. He assumes that the reader will recognize this as poetry; in a way, he’s assuming that the reader is familiar with a whole poetic tradition. The reader is supposed to notice that alternate lines rhyme, but that the others do not, and so on.&lt;/p&gt;

&lt;p&gt;艾略特还认定读者们会慢慢阅读这首诗，并注意到那些意象：回忆与灰尘的并 置，年老与冬日的关联，将等待死亡降临比作手背上的羽毛等等。读者应该能够 读到这首诗的本质，换句话说，读者应该通晓诗歌的创作传统；读者还应注意到 这首诗押隔行韵等等……这些都是艾略特对自己读者做的假设。&lt;/p&gt;

&lt;p&gt;Most of all, he assumes that the reader will read not only with the mind, but also with his/her emotions and imagination, allowing the images to summon up this old man, tired of life but hanging on, waiting expectantly for some crucial event, for something to happen.&lt;/p&gt;

&lt;p&gt;大多数情况，他假设读者不仅仅用思想，也用感情和想像去阅读，让已经对人生 感到疲惫，但是仍在坚持，在期待着某些重要的大事将会发生的老人形像鲜明起来。&lt;/p&gt;

&lt;p&gt;Most math books are written with assumptions about the audience: that they know certain things, that they have a certain level of “mathematical maturity,” etc. Before you start to read, make sure you know what the author expects you to know.&lt;/p&gt;

&lt;p&gt;大多数数学书假定读者为：他们有一定程度的基础，已经有一个确定的“数学基 础”等等。在你开始阅读之前，请确认你已经了解作者希望你了解的知识。&lt;/p&gt;

&lt;h2 id=&quot;an-example-of-mathematical-writing&quot;&gt;An Example of Mathematical Writing　一个数学写作的例子&lt;/h2&gt;
&lt;p&gt;To allow an opportunity to experiment with the guidelines presented here, I am including a small piece of mathematics often called the birthday paradox. The first part is a concise mathematical article explaining the problem and solving it. The second is an imaginary Reader’s attempt to understand the article by using the appropriate reading protocol. This article’s topic is probability and is accessible to a bright and motivated reader with no background at all.&lt;/p&gt;

&lt;p&gt;为了做个实验来展示这里介绍的能力和方法，我引入了名为“生日悖论”的数学 讨论。第一分部分是是一篇数学论文，讲解这个问题并解决它，第二部分是一个 虚构的读者尝试使用之前的阅读规则以理解它。该论文的主题是概率论，它可以 为完全没有知识背景但聪明、积极的读者所理解。&lt;/p&gt;

&lt;h3 id=&quot;the-birthday-paradox&quot;&gt;The Birthday Paradox　生日悖论&lt;/h3&gt;
&lt;p&gt;A professor in a class of 30 random students offers to bet that there are at least two people in the class with the same birthday (month and day, but not necessarily year). Do you accept the bet? What if there were fewer people in the class? Would you bet then?&lt;/p&gt;

&lt;p&gt;有个教授打赌说他班上的30个学生中至少有两个生日在同一天（同月同日，可以 是不同年）。你要不要跟他打赌？如果班上的人再少些呢？还要不要赌？&lt;/p&gt;

&lt;p&gt;Assume that the birthdays of n people are uniformly distributed among 365 days of the year (assume no leap years for simplicity). We prove that, the probability that at least two of them have the same birthday (month and day) is equal to:&lt;/p&gt;

&lt;p&gt;假设 n 个人的生日平均分布在一年的 365 天中（简单起见，不考虑闰年）。我 们证明，至少有两人生日相同的概率为：&lt;/p&gt;

&lt;p&gt;What is the chance that among 30 random people in a room, there are at least two or more with the same birthday? For n = 30, the probability of at least one matching birthday is about 71%. This means that with 30 people in your class, the professor should win the bet 71 times out of 100 in the long run. It turns out that with 23 people, she should win about 50% of the time.&lt;/p&gt;

&lt;p&gt;同一个班中随机的 30 人，至少有两人生日相同的机率是多少？令 n = 30 ，至 少两人生日想同的概率是 71% 。这意味着教授一直在找 30 人的班打这个赌， 长期来讲他 100 次里能赢 71 次。23 个人的话，她的赢面是 50% 。&lt;/p&gt;

&lt;p&gt;Here is the proof: Let P(n) be the probability in question. Let Q(n) = 1 – P(n) be the probability that no two people have a common birthday. Now calculate Q(n) by calculating the number of n birthdays without any duplicates and divide by the total number of n possible birthdays. Then solve for P(n).&lt;/p&gt;

&lt;p&gt;这里有个修正：令 P(n) 为问题中的概率。令 Q(n) = 1 - P(n) 为不存在两个 生日相同的人的概率。现在计算所有 n 个生日的可能性中，全部不重复的概率 Q(n)。然后求得 P(n)。&lt;/p&gt;

&lt;p&gt;The total number of n birthdays without duplicates is:&lt;/p&gt;

&lt;p&gt;n 个生日的所有不重复的组合是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
365 × 364 × 363 × ... × (365 – n + 1).
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is because there are 365 choices for the first birthday, 364 for the next and so on for n birthdays. The total number of n birthdays without any restriction is just 365 n because there are 365 choices for each of n birthdays. Therefore, Q(n) equals&lt;/p&gt;

&lt;p&gt;这因为第一个人有365种可能的选择，第二个人有 364 种可能，依次递推直至第 n 个生日。所有 n 种无限制的生日就是 365 n 。因此，Q(n) 等于&lt;/p&gt;

&lt;p&gt;Solving for P(n) gives P(n) = 1 – Q(n) and hence our result.&lt;/p&gt;

&lt;p&gt;根据 P(n) = 1 - Q(n) ，求得 P(n)，解之可得前述答案。&lt;/p&gt;

&lt;p&gt;Our Reader Attempts to Understand the Birthday Paradox 阅读理解
In this section, a naive Reader tries to make sense out of the last few paragraphs. The Reader’s part is a metaphor for the Reader thinking out loud, and the Professional’s comments represent research on the Reader’s part. The appropriate protocols are centered and bold at various points in the narrative.&lt;/p&gt;

&lt;p&gt;这一节中，一个新手读者想要读懂最后几段。下面的“读者”表示我们虚构的那位读 者，“教授”的注解表示与读者的探讨。在叙述中涉及的几点规则居中加粗表 示&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;My Reader may seem to catch on to things relatively quickly. However, be assured that in reality a great deal of time passes between each of my Reader’s comments, and that I have left out many of the Reader’s remarks that explore dead-end ideas. To experience what the Reader experiences requires much more than just reading through his/her lines. Think of his/her part as an outline for your own efforts.&lt;/p&gt;

&lt;p&gt;这位读者看起来好像很快找到了事物的相关性。然而，为了确认这一点，要在他 的评注中花去大量的时间，我会略过那些他钻牛角尖的讨论。为了体验到读者的 经验，就要深入到他／她的字里行见。通过你的努力去想像他／她的思路。&lt;/p&gt;

&lt;h3 id=&quot;know-thyself-&quot;&gt;Know Thyself 自省&lt;/h3&gt;

&lt;p&gt;Reader (R): I don’t know anything about probability, can I still make it through?&lt;/p&gt;

&lt;p&gt;我一点儿也不了解概率，我还能读懂它吗？&lt;/p&gt;

&lt;p&gt;Professional (P): Let’s give it a try. We may have to backtrack a lot at each step.&lt;/p&gt;

&lt;p&gt;让我们试试看，我们可能要回溯好多步。&lt;/p&gt;

&lt;p&gt;R: What does the phrase “30 random students” mean?&lt;/p&gt;

&lt;p&gt;“任意的” 30 个学生是什么意思？&lt;/p&gt;

&lt;p&gt;“When I use a word, it means just what I choose it to mean 当我使用一个词，它就是我为它选择的意思”&lt;/p&gt;

&lt;p&gt;P: Good question. It doesn’t mean that we have 30 spacy or scatter-brained people. It means we should assume that the birthdays of these 30 people are independent of one another and that every birthday is equally likely for each person. The author writes this more technically a little further on: “Assume that the birthdays of n people are uniformly distributed among 365 days of the year.”&lt;/p&gt;

&lt;p&gt;好问题，它不是说我们有 30 个宽广的或者心不在焉的人。它的意思是我们假定 这 30 个人每个人的生日都独立于其他人，选择机会都完全平等。更技术化一点 的说法是：“假设这 n 个人的生日平均分布于一年的 365 天中。”&lt;/p&gt;

&lt;p&gt;R: Isn’t that obvious? Why bother saying that?&lt;/p&gt;

&lt;p&gt;这不是很明显么？为什么要说的这么罗嗦？&lt;/p&gt;

&lt;p&gt;P: Yes the assumption is kind of obvious. The author is just setting the groundwork. The sentence guarantees that everything is normal and the solution does not involve some imaginitive fanciful science-fiction.&lt;/p&gt;

&lt;p&gt;是的，某种意义上来讲这个假设很明显。作者只是做一个背景设定。这个声明确 认每件事都是平凡的，这个解答不会引入什么科幻小说式的想像。&lt;/p&gt;

&lt;p&gt;R: What do you mean?&lt;/p&gt;

&lt;p&gt;你的意思是？&lt;/p&gt;

&lt;p&gt;P: For example, the author is not looking for a solution like this: everyone lives in Independence Land and is born on the 4th of July, so the chance of two or more people with the same birthday is 100%. That is not the kind of solution mathematicians enjoy. Incidentally, the assumption also implies that we do not count leap years. In particular, nobody in this problem is born on February 29. Continue reading.&lt;/p&gt;

&lt;p&gt;例如，作者没有做这样的解答：每个人都生活在一个独立的大陆，生于七月四 日，所以每两个或更多的人生日相同的机率为 100%。这不是数学家喜欢的答案。 顺便说一下，这个假设还意味着我们不需要计算闰年，特别是这个问题中没有人 生于二月二十九日。下一个。&lt;/p&gt;

&lt;p&gt;R: I don’t understand that long formula, what’s n?&lt;/p&gt;

&lt;p&gt;我不理解那个很长的公式，什么是 n？&lt;/p&gt;

&lt;p&gt;P: The author is solving the problem for any number of people, not just for 30. The author, from now on, is going to call the number of people n.&lt;/p&gt;

&lt;p&gt;作者解决了任意多个人的问题，不止是 30，于是作者称人数为 n。&lt;/p&gt;

&lt;p&gt;R: I still don’t get it. So what’s the answer?&lt;/p&gt;

&lt;p&gt;我不太理解，所以那个答案是？&lt;/p&gt;

&lt;p&gt;Don’t Be a Passive Reader - Try Some Examples 不要做一个被动的读者，尝试一下&lt;/p&gt;

&lt;p&gt;P: Well, if you want the answer for 30, just set n = 30.&lt;/p&gt;

&lt;p&gt;好的，如果你想知道 30 人时的答案，n 就是 30。&lt;/p&gt;

&lt;p&gt;R: Ok, but that looks complicated to compute. Where’s my calculator? Let’s see: 365 × 364 × 363 × … × 336. That’s tedious, and the final exact value won’t even fit on my calculator. It reads:&lt;/p&gt;

&lt;p&gt;OK，不过看起来计算过程很复杂。我的计算器哪儿去了？我们看看： 365 × 364 × 363 × … × 336 。这也太可怕了，我的计算器都显示不全结果了。 它读作：&lt;/p&gt;

&lt;p&gt;2.1710301835085570660575334772481e+76&lt;/p&gt;

&lt;p&gt;If I can’t even calculate the answer once I know the formula, how can I possibly understand where the formula comes from?&lt;/p&gt;

&lt;p&gt;如果我所知的这个公式都不能拿来让我算一次答案，我怎么理解它呢？&lt;/p&gt;

&lt;p&gt;P: You are right that this answer is inexact, but if you actually go on and do the division, your answer won’t be too far off.&lt;/p&gt;

&lt;p&gt;没错，答案并不准确。不过，如果你用除法去消元，就根本不会有这么复杂。&lt;/p&gt;

&lt;p&gt;R: The whole thing makes me uncomfortable. I would prefer to be able to calculate it more exactly. Is there another way to do the calculation?&lt;/p&gt;

&lt;p&gt;这事儿让我很感棘手。我想把它算得更精确一点。有没有其它的算法？&lt;/p&gt;

&lt;p&gt;P: How many terms in your product? How many terms in the product on the bottom?&lt;/p&gt;

&lt;p&gt;你乘了几顶？底部的式子总共要多少项相乘？&lt;/p&gt;

&lt;p&gt;R: You mean 365 is the first term and 364 is the second? Then there are 30 terms. There are also 30 terms on the bottom, (30 copies of 365).&lt;/p&gt;

&lt;p&gt;你的意思是 365 是第一项，364 是第二项？那么有 30 项，下面也有 30 项 ，（30 个 365）.&lt;/p&gt;

&lt;p&gt;P: Can you calculate the answer now?&lt;/p&gt;

&lt;p&gt;现在你能计算答案了吗？&lt;/p&gt;

&lt;p&gt;R: Oh, I see. I can pair up each top term with each bottom term, and do 365/365 as the first term, then multiply by 364/365, and so on for 30 terms. This way the product never gets too big for my calculator. (After a few minutes)… Okay, I got 0.29368, rounded to 5 places.&lt;/p&gt;

&lt;p&gt;哦，我看看。我可以将每一个分子和每一个分母因数配对，第一顶是 365/365， 然后乘 364/365，类推 30 项。这样对我的计算器来说这个乘法不是很大了。 （过几分钟后）……OK，我求得 0.29368。5位精度。&lt;/p&gt;

&lt;p&gt;P: What does this number mean?&lt;/p&gt;

&lt;p&gt;那么这个整数意味着什么？&lt;/p&gt;

&lt;p&gt;Don’t Miss the Big Picture 不要失去大局观&lt;/p&gt;

&lt;p&gt;R: I forgot what I was doing. Let’s see. I was calculating the answer for n = 30. The 0.29368 is everything except for subtracting from 1. If I keep going I get 0.70632. Now what does that mean?&lt;/p&gt;

&lt;p&gt;我忘了我要干啥了。让我想想，我计算了 n=30 时的答案。从一中减去所求之后 为 0.29368 。接下去我可以求得 0.70632。那么这说明了什么？&lt;/p&gt;

&lt;p&gt;P: Knowing more about probability would help, but this simply means that the chance that two or more out of the 30 people have the same birthday is 70,632 out of 100,000 or about 71%.&lt;/p&gt;

&lt;p&gt;知道多一点更好理解，不过也可以简单的理解为 100,000 次实验中，有 70,632 次机会，30 个人中有至少两个生日相同，这个机率约为 71%。&lt;/p&gt;

&lt;p&gt;R: That’s interesting. I wouldn’t have guessed that. You mean that in my class with 30 students, there’s a pretty good chance that at least two students have the same birthday?&lt;/p&gt;

&lt;p&gt;这很有趣，我没有想到。你的意思是我班上有 30 个学生的话，有很大的机会至 少有两个学生生日想同？&lt;/p&gt;

&lt;p&gt;P: Yes that’s right. You might want to take bets before you ask everyone their birthday. Many people don’t thinkthat a duplicate will occur. That’s why some authors call this the birthday paradox.&lt;/p&gt;

&lt;p&gt;没错，就是这意思。你在问过他们生日前可能很想打这个赌。很多人都没有想到 会有重复出现。这就是为什么有些作者称之为生日悖论。&lt;/p&gt;

&lt;p&gt;R: So that’s why I should read mathematics, to make a few extra bucks?&lt;/p&gt;

&lt;p&gt;所以我应该读些数学，可以弄点儿外快？&lt;/p&gt;

&lt;p&gt;P: I see how that might give you some incentive, but I hope the mathematics also inspires you without the monetary prospects.&lt;/p&gt;

&lt;p&gt;这事儿看来给了你一些鼓励，不过我希望数学还能激励你多一些非功利的想法。&lt;/p&gt;

&lt;p&gt;R: I wonder what the answer is for other values of n. I will try some more calculations.&lt;/p&gt;

&lt;p&gt;我对 n 为其它值的答案很有兴趣，我想再多算几个。&lt;/p&gt;

&lt;p&gt;P: That’s a good idea. We can even make a picture out of all your calculations. We could plot a graph of the number of people versus the chance that a duplicate birthday occurs, but maybe this can be left for another time.&lt;/p&gt;

&lt;p&gt;是个好主意，我们甚至可以把你所有的计算结果画成图。我们可以来个人数与生 日重复事件之意的关系曲线，不过这事儿可以下次再弄。&lt;/p&gt;

&lt;p&gt;R: Oh look, the author did some calculations for me. He says that for n = 30 the answer is about 71%; that’s what I calculated too. And, for n = 23 it’s about 50%. Does that make sense? I guess it does. The more people there are, the greater the chance of a common birthday. Hey, I am anticipating the author. Pretty good. Okay, let’s go on.&lt;/p&gt;

&lt;p&gt;瞧，作者为我做了一些计算，他说 n=30 时答案约为 71%，我验算过了。并且， n=23 时答案约为 50%。这可信吗？我觉得可以。选更多的人数，生日重复的机 会总是会更大。嘿，我会抢答了。太棒了。OK，我们继续。&lt;/p&gt;

&lt;p&gt;P: Good, now you’re telling me when to continue.&lt;/p&gt;

&lt;p&gt;很好，现在你觉得我们可以继续了。&lt;/p&gt;

&lt;h3 id=&quot;dont-read-too-fast--1&quot;&gt;Don’t Read Too Fast 不要读的太快&lt;/h3&gt;

&lt;p&gt;R: It seems that we are up to the proof. This must explain why that formula works. What’s this Q(n)? I guess that P stands for probability but what does Q stand for?&lt;/p&gt;

&lt;p&gt;看起来我们做出了证明。我们一定要弄清公式的原理。什么是 Q(n) ？我猜 P 代表概率的意思，不过 Q 代表什么？&lt;/p&gt;

&lt;p&gt;P: The author is defining something new. He is using Q just because it’s the next letter after P, but Q(n) is also a probability, and closely related to P(n). It’s time to take a minute to think. What is Q(n) and why is it equal to 1 – P(n)?&lt;/p&gt;

&lt;p&gt;作者定义了很多东西，这里使用 Q 只是因为它是 P 的下一个字母。Q(n) 也是 个概率，它强相关于 P(n)。我们该花几分钟想想了。什么是 Q(n)？为什么它等 于 1 - P(n)？&lt;/p&gt;

&lt;p&gt;R: Q(n) is the probability that no two people have the same birthday. Why does the author care about that? Don’t we want the probability that at least two have the same birthday?&lt;/p&gt;

&lt;p&gt;Q(n) 是没有生日相同的概率，为什么作者强调这个？我们不能去考虑至少两个 人在同一个生日的概率？&lt;/p&gt;

&lt;p&gt;P: Good point. The author doesn’t tell you this explicitly, but between the lines, you can infer that he has no clue how to calculate P(n) directly. Instead, he introduces Q(n) which supposedly equals 1 – P(n). Presumably, the author will proceed next to tell us how to compute Q(n). By the way, when you finish this article, you may want to deal with the problem of calculating P(n) directly. That’s a perfect follow up to the ideas presented here.&lt;/p&gt;

&lt;p&gt;很好。作者没有明确的告诉你，但是在文中你可以看出他没办法直接计算 P(n)。 相反他引入了相当于 1-P(n) 的 Q(n)。大概作者接下来会告诉我们如何计算 Q(n)。顺便，当你读完论文，可能想解决直接计算 P(n) 的方法。这是个很好的 想法。&lt;/p&gt;

&lt;p&gt;R: First things first.&lt;/p&gt;

&lt;p&gt;那就尽快动手吧。&lt;/p&gt;

&lt;p&gt;P: Ok. So once we know Q(n), then what?&lt;/p&gt;

&lt;p&gt;OK，我们知道 Q(n) 以后，接下来干什么？&lt;/p&gt;

&lt;p&gt;R: Then we can get P(n). Because if Q(n) = 1 – P(n), then P(n) = 1 – Q(n). Fine, but why is Q(n) = 1 – P(n)? Does the author assume this is obvious?&lt;/p&gt;

&lt;p&gt;我们可以得到 P(n)。因为如果 Q(n) = 1 - P(n)，那么 P(n) = 1 - Q(n)。很 好，但是为什么 Q(n) = 1 - P(n)？作者认为这很明显么？&lt;/p&gt;

&lt;p&gt;P: Yes, he does, but what’s worse, he doesn’t even tell us that it is obvious. Here’s a rule of thumb: when an author says clearly this is true or this is obvious, then take 15 minutes to convince yourself it is true. If an author doesn’t even bother to say this, but just implies it, take a little longer.&lt;/p&gt;

&lt;p&gt;是啊，他这么想，更糟糕的是他甚至没说这是显然的。有一个基本守则：如果某 作者对你说这是显然的或肯定为真，那就应该能在 15 分钟内向你说明。如果该 作者甚至懒得说出这一点，只是暗示了一下，大概会花更长时间。&lt;/p&gt;

&lt;p&gt;R: How will I know when I should stop and think?&lt;/p&gt;

&lt;p&gt;我怎么知道我应该在哪里停下来？&lt;/p&gt;

&lt;p&gt;P: Just be honest with yourself. When in doubt, stop and think. When too tired, go watch television.&lt;/p&gt;

&lt;p&gt;诚实的面对自己就好了。因惑的时候就停下来想一想。太累了就去看看电视。&lt;/p&gt;

&lt;p&gt;R: So why is Q(n) = 1 – P(n)?&lt;/p&gt;

&lt;p&gt;那么为什么 Q(n) = 1 – P(n) ？&lt;/p&gt;

&lt;p&gt;P: Let’s imagine a special case. If the chance of getting two or more of the same birthdays is 1/3, then what’s the chance of not getting two or more?&lt;/p&gt;

&lt;p&gt;让我们想像一个特殊的情况。如果有两个或更多的人同一生日的机率是 1/3。那 么没有两个或更多重复的机率是多少？&lt;/p&gt;

&lt;p&gt;R: It’s 2/3, because the chance of something not happening is the opposite of the chance of it happening.&lt;/p&gt;

&lt;p&gt;是 2/3 。因为没发生某事的机率是发生此事件的机率的互斥数。&lt;/p&gt;

&lt;p&gt;Make the Idea Your Own 建立你自己的思想&lt;/p&gt;

&lt;p&gt;P: Well, you should be careful when you say things like opposite, but you are right. In fact, you have discovered one of the first rules taught in a course on probability. Namely, that the probability that something will not occur is 1 minus the probability that it will occur. Now go on to the next paragraph.&lt;/p&gt;

&lt;p&gt;很好，讨论对互斥性的时候要小心一些，不过你答对了。事实上你已经在概率论 的道路上发现了第一个法则。即某事件发生的概率是 1 减它没有发生的概率。 现在我们讨论下一部分。&lt;/p&gt;

&lt;p&gt;R: It seems to be explaining why Q(n) is equal to long complex-looking formula shown. I will never understand this.&lt;/p&gt;

&lt;p&gt;看来这解释了为什么 Q(n) 等于看起来这么复杂的公式。我可能永远也理解不了。&lt;/p&gt;

&lt;p&gt;P: The formula for Q(n) is tough to understand and the author is counting on your diligence, persistence, and/or background here to get you through.&lt;/p&gt;

&lt;p&gt;Q(n) 的公式确实很难理解，作者也是像你一样坚持不懈的计算和推导中才做到。&lt;/p&gt;

&lt;p&gt;R: He seems to be counting all possibilities of something and dividing by the total possibilities, whatever that means. I have no idea why.&lt;/p&gt;

&lt;p&gt;不管怎么说，看起来他计算了某事所有的可能性再除总的可能性。我不太理解。&lt;/p&gt;

&lt;p&gt;P: Maybe I can fill you in here on some background before you try to check out any more details. The probability of the occurrence of a particular type of outcome is defined in mathematics to be: the total number of possible ways that type of outcome can occur divided by the total number of possible outcomes. For example, the probability that you throw a four when throwing a die is 1/6. Because there is one possible 4, and there are six possible outcomes. What’s the probability you throw a four or a three?&lt;/p&gt;

&lt;p&gt;可能在你发掘出更多细节前，我可以给你一些背景知识。某一特定类型的事件发 生的概率在数学上定义为：此类事件所有可能发生的结果总和除以此类型事件可 能发生的总数。例如，你扔骰子时扔出 4 的概率是 1／6.因为有六种可能，4 是其中一种。你扔出 4 或 3 的概率是多少？&lt;/p&gt;

&lt;p&gt;R: Well I guess 2/6 (or 1/3) because the total number of outcomes is still six but I have two possible outcomes that work.&lt;/p&gt;

&lt;p&gt;我猜是 2/6 （即 1/3）。因为所有可能结果的总数是6，但是我有两种可能的结 果。&lt;/p&gt;

&lt;p&gt;P: Good. Here’s a harder example. What about the chance of throwing a sum of four when you roll two dice? There are three ways to get a four (1-3, 2-2, 3-1) while the total number of possible outcomes is 36. That is 3/36 or 1/12. Look at the following 6 by 6 table and convince yourself.&lt;/p&gt;

&lt;p&gt;很好，有个更难一点儿的例子。当你扔两个骰子的时候，扔出 4 的概率是多大 呢？在所有36种可能中，有三种可能会扔出四（1-3，2-2，3-1）。即3／36，也 就是 1／12。你可以根据下面的 6x6 表格验证一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1-1, 1-2, 1-3, 1-4, 1-5, 1-6
2-1, 2-2, 2-3, 2-4, 2-5, 2-6
3-1, 3-2, 3-3, 3-4, 3-5, 3-6
4-1, 4-2, 4-3, 4-4, 4-5, 4-6
5-1, 5-2, 5-3, 5-4, 5-5, 5-6
6-1, 6-2, 6-3, 6-4, 6-5, 6-6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What about the probability of throwing a 7?&lt;/p&gt;

&lt;p&gt;扔出 7 的机率是多少？&lt;/p&gt;

&lt;p&gt;R: Wait. What does 1-1 mean? Doesn’t that equal 0?&lt;/p&gt;

&lt;p&gt;等等， 1-1 是什么意思？不应该是0么？&lt;/p&gt;

&lt;p&gt;P: Sorry, my bad. I was using the minus sign as a dash, just to mean a pair of numbers, so 1-1 means a roll of one on each die - snake eyes.&lt;/p&gt;

&lt;p&gt;对不起，我的错。我推进的太快了。这里只代表一对数字， 1-1 表示扔出两个 1.&lt;/p&gt;

&lt;p&gt;R: Couldn’t you have come up with a better notation?&lt;/p&gt;

&lt;p&gt;你不能找个更好的标注法么？&lt;/p&gt;

&lt;p&gt;P: Well maybe I could/should have, but commas would look worse, a slash would look like division, and anything else might be just as confusing. We aren’t going to publish this transcript anyway.&lt;/p&gt;

&lt;p&gt;说不定有更好的方法，不过逗号看起来好浪费，斜杠看起来像除法，每一种看起 来都有些岐义。不管怎么说，我们又不会拿这个手抄本去出版。&lt;/p&gt;

&lt;p&gt;R: That’s a relief. Well, I know what you mean now. To answer your question, I can get a seven in six ways via 1-6, 2-5, 3-4, 4-3, 5-2, or 6-1. The total number of outcomes is still 36, so I get 6/36 or 1/6. That’s weird, why isn’t the chance of rolling a 4 the same as for rolling a 7?&lt;/p&gt;

&lt;p&gt;好的，我知道你的意思了。为了回答你的问题，我找到了六种可能的组合 1-6, 2-5, 3-4, 4-3, 5-2, 和 6-1 。结果的总数还是36，所以我求得 6/36，即 1/6。这太奇怪了，为什么 扔出 4 的机率和 扔出 7 的不一样？&lt;/p&gt;

&lt;p&gt;P: Because not every sum is equally likely. The situation would be very different if we were simply spinning a wheel with the sums 2 through 12 listed in equally spaced intervals. In that case, each one of the 11 sums would have probability 1/11.&lt;/p&gt;

&lt;p&gt;因为不是每种总数都一样。这种情况跟我们简单的在 12 种平均分布的样本中任 取两个不一样。这种情况下，11 个样本中任选一个的机率是 1／11。&lt;/p&gt;

&lt;p&gt;R: Okay, now I am an expert. Is probability just about counting?&lt;/p&gt;

&lt;p&gt;OK，现在我也是专家了。概率就是数数嘛。&lt;/p&gt;

&lt;p&gt;P: Sometimes, yes. But counting things is not always so easy.&lt;/p&gt;

&lt;p&gt;某种意义上是这样，不过有时候数数也很难啊。&lt;/p&gt;

&lt;p&gt;R: I see, let’s go on. By the way, did the author really expect me to know all this? My friend took Probability and Statistics and I am not sure he knows all this stuff.&lt;/p&gt;

&lt;p&gt;我懂，咱们继续。顺便问一句，作者真的认为我应该对这些都懂吗？我的朋友就 是搞概率和统计的，我觉得他也未必都懂。&lt;/p&gt;

&lt;p&gt;P: There’s a lot of information implied in a small bit of mathematics. Yes, the author expected you to know all this, or to discover it yourself just as we have done. If I hadn’t been here, you would have had to ask yourself these questions and answer them by thinking, looking in a reference book, or consulting a friend.&lt;/p&gt;

&lt;p&gt;这些东西只是数学知识的沧海一粟。没错，作者希望你都懂，或者就像你刚才那 样去学习它们。如果我不在这儿，你可以向自己提问，然后通过思考，查阅参考 书或请教朋友去弄懂它们。&lt;/p&gt;

&lt;p&gt;R: So the chance that there are no two people with the same birthday is the number of possible sets of n birthdays without a duplicate divided by the total number of possible sets of n birthdays.&lt;/p&gt;

&lt;p&gt;所以没有两人生日相同的机率是n个人所有可能的生日的总数除以所有不重复生 日的组合数目的商。&lt;/p&gt;

&lt;p&gt;P: Excellent summary.&lt;/p&gt;

&lt;p&gt;完全正确。&lt;/p&gt;

&lt;p&gt;R: I don’t like using n, so let me use 30. Perhaps the generalization to n will be easy to see.&lt;/p&gt;

&lt;p&gt;我不喜欢用 n，那我用 30。可能用 n 来表示更为通用。&lt;/p&gt;

&lt;p&gt;P: Great idea. It is often helpful to look at a special case before understanding the general case.&lt;/p&gt;

&lt;p&gt;太对了。通常在理解通用情况时我们会先尝试特定的情景。&lt;/p&gt;

&lt;p&gt;R: So how many sets of 30 birthdays are there total? I can’t do it. I guess I need to restrict my view even more. Let’s pretend there are only two people.&lt;/p&gt;

&lt;p&gt;那么 30 人生日总共有多少种组合？我算不出来，大概得再加一些限制。让我们 假设只有两个人的情况。&lt;/p&gt;

&lt;p&gt;P: Fine. Now you’re thinking like a mathematician. Let’s try n = 2. How many sets of two birthdays are there total?&lt;/p&gt;

&lt;p&gt;很好，现在你开始像个数学家一样思考了，让我们考虑一下 n = 2。有多少种生 日组合？&lt;/p&gt;

&lt;p&gt;R: I number the birthdays from 1 to 365 and forget about leap years. Then these are the all the possibilities:&lt;/p&gt;

&lt;p&gt;忽略闰年，记可能的生日为1到365.下面是所有的可能：
~~~
1-1, 1-2, 1-3, … , 1-365,
2-1, 2-2, 2-3, … , 2-365,
…
365-1, 365-2, 365-3, … , 365-365.
~~~
P: When you write 1-1, do you mean 1-1 = 0, as in subtraction?&lt;/p&gt;

&lt;p&gt;这里你写的 1-1 不是 1-1=0？&lt;/p&gt;

&lt;p&gt;R: Stop teasing me. You know exactly what I mean.&lt;/p&gt;

&lt;p&gt;别想糊弄我，你知道我的意思。&lt;/p&gt;

&lt;p&gt;P: Yes I do, and nice choice of notation I might add. Now how many pairs of birthdays are there?&lt;/p&gt;

&lt;p&gt;好的，看来我选的这个标记还挺好用。现在有多少对生日组合？&lt;/p&gt;

&lt;p&gt;R: There are 365 × 365 total possibilities for two people.&lt;/p&gt;

&lt;p&gt;两个人的话共有 365 x 365 种可能。&lt;/p&gt;

&lt;p&gt;P: And how many are there when there are no duplicate birthdays?&lt;/p&gt;

&lt;p&gt;那么有多少种不重复的组合？&lt;/p&gt;

&lt;p&gt;R: I can’t use 1-1, or 2-2, or 3-3 or … 365-365, so I get&lt;/p&gt;

&lt;p&gt;去掉 1-1 或 2-2 或 3-3……那么得到&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1-2, 1-3, … , 1-365, 2-1, 2-3, … , 2-365, … 365-1, 365-2, … , 365-364
The total number here is 365 × 364 since each row now has 364 pairs instead of 365.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;总共有 365 x 364 种，因为现在每行有 364 对而不是 365。&lt;/p&gt;

&lt;p&gt;P: Good. You are going a little quickly here, but you’re 100% right. Can you generalize now to 30? What is the total number of possible sets of 30 birthdays? Take a guess. You’re getting good at this.&lt;/p&gt;

&lt;p&gt;很好。这次你做的很快，不过完全弄对了。30 人生日的总的样本数是多少？猜 猜看，你很擅长这个的。&lt;/p&gt;

&lt;p&gt;R: Well if I had to guess, (it’s not really a guess, after all, I already know the formula), I would say that for 30 people you get 365 × 365 ×… × 365, 30 times, for the total number of possible sets of birthdays.&lt;/p&gt;

&lt;p&gt;OK让我猜一下，（也不算真的猜，毕竟我知道公式），30 人生日的所有可能样 本是 365 x 365 x 365 … x365，共 30 次。&lt;/p&gt;

&lt;p&gt;P: Exactly. Mathematicians write 365 30 . And what is the number of possible sets of 30 birthdays without any duplicates?&lt;/p&gt;

&lt;p&gt;很好，数学家会将其写做 365 30 。那么 30 个不重复的生日 组合会是多少？&lt;/p&gt;

&lt;p&gt;R: I know the answer should be 365 × 364 × 363 × 362 × … × 336, (that is, start at 365 and multiply by one less for 30 times), but I am not sure I really see why this is true. Perhaps I should do the case with three people first, and work my way up to 30?&lt;/p&gt;

&lt;p&gt;我知道这个答案应该是 365 × 364 × 363 × 362 × … × 336 ,（即从 365 开始逐项递减相乘，共 30 项），但是我不确信它是对的。或许我应该先算 一下三个人的，然后逐项增加到 30？&lt;/p&gt;

&lt;p&gt;P: Splendid idea. Let’s quit for today. The whole picture is there for you. When you are rested and you have more time, you can come back and fill in that last bit of understanding.&lt;/p&gt;

&lt;p&gt;这个想法非常好。今天先到这里。你已经有了自己的构思。等你休息一下，有了 时间，可以回来完成最终的学习和理解。&lt;/p&gt;

&lt;p&gt;R: Thanks a lot; it’s been an experience. Later.&lt;/p&gt;

&lt;p&gt;非常感谢，我学到了很多知识。再见。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Emblems of Mind, Edward Rothstein, Avon Books, page 15.&lt;a href=&quot;#fnref:1&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;ibid, page 16.&lt;a href=&quot;#fnref:2&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;ibid, page 38&lt;a href=&quot;#fnref:3&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;ibid, page 16.&lt;a href=&quot;#fnref:4&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;《西面颂歌》是大诗人艾略特所作，西面是圣经故事中的先知。能力所限，此处不译——译者。&lt;a href=&quot;#fnref:5&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;由于使用的文档工具问题，您看到的可能只是加粗，我尽量在 HTML 格式中还原原文的格式，并单独制作一份 Latex，直接写 HTML 固然可以完全控制格式，但是这对我太影响翻译的效率了——译者。&lt;a href=&quot;#fnref:6&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>为什么会有这个坑</title>
   <link href="http://marchliu.github.com/daily/2013/02/07/"/>
   <updated>2013-02-07T00:00:00+08:00</updated>
   <id>http://marchliu.github.com/daily/2013/02/</id>
   <content type="html">
&lt;p&gt;首先，我希望能有一个比 &lt;a href=&quot;http://zerolabrary.appspot.com&quot;&gt;zerolabrary&lt;/a&gt; 写起来更简单的环境。Zerolabrary 建立在 GAE 上，它的功能足够强了，但是写文章反而比较麻烦。例如翻译 How To Read Mathematica 的时候就还是要借助 sphinx 。Pages 足够简单，更适合日常发布，而且，把它发布到其它地方也很容易。&lt;/p&gt;

&lt;p&gt;另外，我正在寻找更好的建站工具，供 Dwarf Artisan 使用，目前我只是用 iweb 搭了一个应急，那个东西太简陋了，实在不适合企业建站。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>